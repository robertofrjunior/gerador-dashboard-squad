"""
Indicador de Impacto de Negócio - Analisa valor entregue ao negócio.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

from ..utils.log import info, warn, error


class BusinessImpactIndicator:
    """
    Calcula o impacto de negócio baseado em:
    - Valor das funcionalidades entregues
    - Alinhamento com objetivos de negócio
    - Impacto em usuários/clientes
    - ROI das features
    - Redução de riscos
    """
    
    def __init__(self):
        """Inicializa o indicador de impacto de negócio."""
        self.impact_weights = {
            'feature_value': 0.30,       # 30% - Valor das features
            'business_alignment': 0.25,  # 25% - Alinhamento estratégico
            'user_impact': 0.20,         # 20% - Impacto nos usuários
            'roi_potential': 0.15,       # 15% - Potencial de ROI
            'risk_reduction': 0.10       # 10% - Redução de riscos
        }
        
        # Classificação de tipos de tarefa por valor de negócio
        self.business_value_types = {
            'high': ['feature', 'nova funcionalidade', 'melhoria', 'epic'],
            'medium': ['story', 'história', 'enhancement', 'otimização'],
            'low': ['task', 'tarefa', 'sub-task', 'spike'],
            'maintenance': ['bug', 'defeito', 'correção', 'manutenção', 'refactor']
        }
        
        # Palavras-chave que indicam alto valor de negócio
        self.high_value_keywords = [
            'receita', 'revenue', 'vendas', 'conversão', 'customer',
            'cliente', 'usuário', 'experiência', 'performance',
            'segurança', 'compliance', 'legal', 'estratégic'
        ]
    
    def calculate_business_impact(self, df: pd.DataFrame, 
                                 business_context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Calcula o impacto de negócio das entregas.
        
        Args:
            df: DataFrame com dados dos itens da sprint
            business_context: Contexto adicional do negócio (OKRs, metas, etc.)
            
        Returns:
            Dicionário com análise completa de impacto
        """
        try:
            info("Calculando impacto de negócio...")
            
            if df.empty:
                return self._get_default_result()
            
            # 1. Análise de valor das features
            feature_value = self._analyze_feature_value(df)
            
            # 2. Análise de alinhamento com negócio
            business_alignment = self._analyze_business_alignment(df, business_context)
            
            # 3. Análise de impacto nos usuários
            user_impact = self._analyze_user_impact(df)
            
            # 4. Análise de potencial de ROI
            roi_potential = self._analyze_roi_potential(df)
            
            # 5. Análise de redução de riscos
            risk_reduction = self._analyze_risk_reduction(df)
            
            # Calcular score geral de impacto
            impact_score = (
                feature_value['score'] * self.impact_weights['feature_value'] +
                business_alignment['score'] * self.impact_weights['business_alignment'] +
                user_impact['score'] * self.impact_weights['user_impact'] +
                roi_potential['score'] * self.impact_weights['roi_potential'] +
                risk_reduction['score'] * self.impact_weights['risk_reduction']
            )
            
            # Classificar impacto
            impact_level = self._classify_impact(impact_score)
            
            # Calcular valor total entregue
            total_value = self._calculate_total_value(df, feature_value, business_alignment)
            
            # Identificar principais contribuições
            key_contributions = self._identify_key_contributions(df, feature_value)
            
            # Gerar insights de negócio
            business_insights = self._generate_business_insights(
                feature_value, business_alignment, user_impact
            )
            
            # Recomendações estratégicas
            strategic_recommendations = self._generate_strategic_recommendations(
                feature_value, business_alignment, roi_potential
            )
            
            result = {
                'impact_score': round(impact_score, 1),
                'impact_level': impact_level,
                'components': {
                    'feature_value': feature_value,
                    'business_alignment': business_alignment,
                    'user_impact': user_impact,
                    'roi_potential': roi_potential,
                    'risk_reduction': risk_reduction
                },
                'total_value': total_value,
                'key_contributions': key_contributions,
                'business_insights': business_insights,
                'strategic_recommendations': strategic_recommendations,
                'value_distribution': self._analyze_value_distribution(df),
                'impact_metrics': self._calculate_impact_metrics(df, impact_score)
            }
            
            info(f"Impacto de negócio: {impact_score:.1f} ({impact_level})")
            return result
            
        except Exception as e:
            error(f"Erro ao calcular impacto de negócio: {e}")
            return self._get_default_result()
    
    def _analyze_feature_value(self, df: pd.DataFrame) -> Dict[str, Any]:
        """Analisa o valor das funcionalidades entregues."""
        try:
            total_items = len(df)
            if total_items == 0:
                return self._get_default_component()
            
            # Classificar itens por valor de negócio
            value_classification = {
                'high_value': 0,
                'medium_value': 0,
                'low_value': 0,
                'maintenance': 0
            }
            
            high_value_items = []
            
            for _, item in df.iterrows():
                item_type = str(item.get('Tipo', '')).lower()
                item_title = str(item.get('Título', '')).lower()
                item_description = str(item.get('Descrição', '')).lower()
                
                # Combinar texto para análise
                combined_text = f"{item_type} {item_title} {item_description}"
                
                # Classificar por tipo
                value_category = 'low_value'  # Default
                
                for category, types in self.business_value_types.items():
                    if any(t in item_type for t in types):
                        value_category = category
                        break
                
                # Ajustar baseado em palavras-chave de alto valor
                high_value_keywords_found = sum(
                    1 for keyword in self.high_value_keywords
                    if keyword in combined_text
                )\n                \n                if high_value_keywords_found >= 2:\n                    value_category = 'high_value'\n                elif high_value_keywords_found >= 1 and value_category == 'low_value':\n                    value_category = 'medium_value'\n                \n                # Mapear para categorias finais\n                if value_category == 'high':\n                    value_classification['high_value'] += 1\n                    high_value_items.append(item.get('Título', 'Item sem título'))\n                elif value_category == 'medium':\n                    value_classification['medium_value'] += 1\n                elif value_category == 'maintenance':\n                    value_classification['maintenance'] += 1\n                else:\n                    value_classification['low_value'] += 1\n                \n                # Considerar story points como proxy de esforço/valor\n                if value_category in ['high_value', 'high'] and 'Story Points' in df.columns:\n                    sp = item.get('Story Points', 0)\n                    if pd.notna(sp) and sp > 0:\n                        # Itens de alto valor com story points altos são mais valiosos\n                        if sp >= 8:\n                            value_category = 'high_value'\n            \n            # Calcular score baseado na distribuição\n            high_ratio = value_classification['high_value'] / total_items\n            medium_ratio = value_classification['medium_value'] / total_items\n            maintenance_ratio = value_classification['maintenance'] / total_items\n            \n            # Score baseado na proporção de itens de alto/médio valor\n            score = (\n                high_ratio * 100 +      # Alto valor = 100 pontos\n                medium_ratio * 70 +     # Médio valor = 70 pontos\n                maintenance_ratio * 30   # Manutenção = 30 pontos (necessário mas não agrega valor direto)\n            )\n            \n            score = min(100, score)  # Cap em 100\n            \n            return {\n                'score': round(score, 1),\n                'value_classification': value_classification,\n                'high_value_ratio': round(high_ratio, 2),\n                'medium_value_ratio': round(medium_ratio, 2),\n                'maintenance_ratio': round(maintenance_ratio, 2),\n                'high_value_items': high_value_items[:5],  # Top 5\n                'interpretation': self._interpret_feature_value(score, high_ratio)\n            }\n            \n        except Exception:\n            return self._get_default_component()\n    \n    def _analyze_business_alignment(self, df: pd.DataFrame, \n                                   business_context: Optional[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"Analisa alinhamento com objetivos de negócio.\"\"\"\n        try:\n            total_items = len(df)\n            if total_items == 0:\n                return self._get_default_component()\n            \n            # Palavras-chave que indicam alinhamento estratégico\n            strategic_keywords = [\n                'objetivo', 'estratégia', 'meta', 'okr', 'kpi',\n                'crescimento', 'expansão', 'market', 'competitiv',\n                'inovação', 'digital', 'transformação'\n            ]\n            \n            aligned_items = 0\n            strategic_items = []\n            \n            for _, item in df.iterrows():\n                item_title = str(item.get('Título', '')).lower()\n                item_description = str(item.get('Descrição', '')).lower()\n                \n                combined_text = f\"{item_title} {item_description}\"\n                \n                # Contar palavras-chave estratégicas\n                strategic_keywords_found = sum(\n                    1 for keyword in strategic_keywords\n                    if keyword in combined_text\n                )\n                \n                if strategic_keywords_found >= 1:\n                    aligned_items += 1\n                    if strategic_keywords_found >= 2:\n                        strategic_items.append(item.get('Título', 'Item sem título'))\n            \n            # Se temos contexto de negócio, fazer análise mais sofisticada\n            if business_context:\n                # Analisar alinhamento com OKRs/metas específicas\n                business_goals = business_context.get('goals', [])\n                if business_goals:\n                    for goal in business_goals:\n                        goal_keywords = goal.lower().split()\n                        for _, item in df.iterrows():\n                            item_text = f\"{item.get('Título', '')} {item.get('Descrição', '')}\".lower()\n                            if any(keyword in item_text for keyword in goal_keywords):\n                                aligned_items += 1\n            \n            alignment_ratio = aligned_items / total_items\n            \n            # Score baseado no alinhamento\n            if alignment_ratio >= 0.7:  # ≥70% alinhado\n                score = 95\n            elif alignment_ratio >= 0.5:  # ≥50% alinhado\n                score = 80\n            elif alignment_ratio >= 0.3:  # ≥30% alinhado\n                score = 65\n            elif alignment_ratio >= 0.15:  # ≥15% alinhado\n                score = 45\n            else:\n                score = 25\n            \n            return {\n                'score': score,\n                'alignment_ratio': round(alignment_ratio, 2),\n                'aligned_items': aligned_items,\n                'total_items': total_items,\n                'strategic_items': strategic_items[:3],  # Top 3\n                'interpretation': self._interpret_business_alignment(score, alignment_ratio)\n            }\n            \n        except Exception:\n            return self._get_default_component()\n    \n    def _analyze_user_impact(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa impacto direto nos usuários.\"\"\"\n        try:\n            total_items = len(df)\n            if total_items == 0:\n                return self._get_default_component()\n            \n            # Palavras-chave que indicam impacto no usuário\n            user_impact_keywords = [\n                'usuário', 'user', 'cliente', 'customer', 'ux', 'ui',\n                'experiência', 'interface', 'usabilidade', 'acessibilidade',\n                'navegação', 'performance', 'velocidade', 'responsivo'\n            ]\n            \n            user_facing_items = 0\n            high_impact_items = []\n            \n            for _, item in df.iterrows():\n                item_title = str(item.get('Título', '')).lower()\n                item_description = str(item.get('Descrição', '')).lower()\n                item_type = str(item.get('Tipo', '')).lower()\n                \n                combined_text = f\"{item_title} {item_description} {item_type}\"\n                \n                # Contar palavras-chave de impacto no usuário\n                user_keywords_found = sum(\n                    1 for keyword in user_impact_keywords\n                    if keyword in combined_text\n                )\n                \n                if user_keywords_found >= 1:\n                    user_facing_items += 1\n                    \n                    if user_keywords_found >= 2:\n                        high_impact_items.append(item.get('Título', 'Item sem título'))\n            \n            user_impact_ratio = user_facing_items / total_items\n            \n            # Score baseado no impacto no usuário\n            if user_impact_ratio >= 0.6:  # ≥60% impacta usuários\n                score = 90\n            elif user_impact_ratio >= 0.4:  # ≥40% impacta usuários\n                score = 75\n            elif user_impact_ratio >= 0.25:  # ≥25% impacta usuários\n                score = 60\n            elif user_impact_ratio >= 0.1:   # ≥10% impacta usuários\n                score = 40\n            else:\n                score = 20\n            \n            return {\n                'score': score,\n                'user_impact_ratio': round(user_impact_ratio, 2),\n                'user_facing_items': user_facing_items,\n                'total_items': total_items,\n                'high_impact_items': high_impact_items[:3],\n                'interpretation': self._interpret_user_impact(score, user_impact_ratio)\n            }\n            \n        except Exception:\n            return self._get_default_component()\n    \n    def _analyze_roi_potential(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa potencial de retorno sobre investimento.\"\"\"\n        try:\n            total_items = len(df)\n            if total_items == 0:\n                return self._get_default_component()\n            \n            # Palavras-chave que indicam potencial de ROI\n            roi_keywords = [\n                'receita', 'revenue', 'vendas', 'sales', 'monetização',\n                'conversão', 'conversion', 'eficiência', 'economia',\n                'redução', 'custo', 'automação', 'produtividade'\n            ]\n            \n            high_roi_items = 0\n            roi_potential_items = []\n            \n            # Analisar story points como proxy de investimento\n            total_story_points = 0\n            high_value_story_points = 0\n            \n            for _, item in df.iterrows():\n                item_title = str(item.get('Título', '')).lower()\n                item_description = str(item.get('Descrição', '')).lower()\n                \n                combined_text = f\"{item_title} {item_description}\"\n                \n                # Contar palavras-chave de ROI\n                roi_keywords_found = sum(\n                    1 for keyword in roi_keywords\n                    if keyword in combined_text\n                )\n                \n                story_points = item.get('Story Points', 0)\n                if pd.notna(story_points) and story_points > 0:\n                    total_story_points += story_points\n                    \n                    if roi_keywords_found >= 1:\n                        high_roi_items += 1\n                        high_value_story_points += story_points\n                        \n                        if roi_keywords_found >= 2:\n                            roi_potential_items.append(item.get('Título', 'Item sem título'))\n            \n            # Calcular ratios\n            roi_items_ratio = high_roi_items / total_items\n            \n            if total_story_points > 0:\n                roi_effort_ratio = high_value_story_points / total_story_points\n            else:\n                roi_effort_ratio = roi_items_ratio  # Fallback\n            \n            # Score baseado no potencial de ROI\n            combined_ratio = (roi_items_ratio + roi_effort_ratio) / 2\n            \n            if combined_ratio >= 0.5:   # ≥50% com potencial de ROI\n                score = 90\n            elif combined_ratio >= 0.3:  # ≥30% com potencial de ROI\n                score = 75\n            elif combined_ratio >= 0.2:  # ≥20% com potencial de ROI\n                score = 60\n            elif combined_ratio >= 0.1:  # ≥10% com potencial de ROI\n                score = 40\n            else:\n                score = 25\n            \n            return {\n                'score': score,\n                'roi_items_ratio': round(roi_items_ratio, 2),\n                'roi_effort_ratio': round(roi_effort_ratio, 2),\n                'high_roi_items': high_roi_items,\n                'total_story_points': total_story_points,\n                'high_value_story_points': high_value_story_points,\n                'roi_potential_items': roi_potential_items[:3],\n                'interpretation': self._interpret_roi_potential(score, combined_ratio)\n            }\n            \n        except Exception:\n            return self._get_default_component()\n    \n    def _analyze_risk_reduction(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa redução de riscos através das entregas.\"\"\"\n        try:\n            total_items = len(df)\n            if total_items == 0:\n                return self._get_default_component()\n            \n            # Palavras-chave que indicam redução de riscos\n            risk_keywords = [\n                'segurança', 'security', 'compliance', 'audit',\n                'vulnerabilidade', 'risco', 'backup', 'recovery',\n                'monitoramento', 'log', 'erro', 'falha', 'estabilidade'\n            ]\n            \n            risk_reduction_items = 0\n            critical_fixes = 0\n            \n            for _, item in df.iterrows():\n                item_title = str(item.get('Título', '')).lower()\n                item_description = str(item.get('Descrição', '')).lower()\n                item_type = str(item.get('Tipo', '')).lower()\n                priority = str(item.get('Prioridade', '')).lower()\n                \n                combined_text = f\"{item_title} {item_description} {item_type}\"\n                \n                # Contar palavras-chave de redução de risco\n                risk_keywords_found = sum(\n                    1 for keyword in risk_keywords\n                    if keyword in combined_text\n                )\n                \n                if risk_keywords_found >= 1:\n                    risk_reduction_items += 1\n                    \n                    # Verificar se é crítico\n                    if 'crítico' in priority or 'critical' in priority or 'high' in priority:\n                        critical_fixes += 1\n            \n            risk_reduction_ratio = risk_reduction_items / total_items\n            critical_ratio = critical_fixes / total_items\n            \n            # Score baseado na redução de riscos\n            # Considerar que redução de risco é importante mas não deve dominar\n            base_score = 60  # Score base neutro\n            \n            if risk_reduction_ratio >= 0.3:  # ≥30% reduz riscos\n                if critical_ratio >= 0.1:  # ≥10% críticos\n                    score = 85  # Muitos riscos críticos resolvidos\n                else:\n                    score = 75  # Boa redução de riscos\n            elif risk_reduction_ratio >= 0.15:  # ≥15% reduz riscos\n                score = 65\n            elif risk_reduction_ratio >= 0.05:  # ≥5% reduz riscos\n                score = 55\n            else:\n                score = base_score  # Pouca ou nenhuma redução de risco\n            \n            return {\n                'score': score,\n                'risk_reduction_ratio': round(risk_reduction_ratio, 2),\n                'critical_fixes_ratio': round(critical_ratio, 2),\n                'risk_reduction_items': risk_reduction_items,\n                'critical_fixes': critical_fixes,\n                'total_items': total_items,\n                'interpretation': self._interpret_risk_reduction(score, risk_reduction_ratio)\n            }\n            \n        except Exception:\n            return self._get_default_component()\n    \n    def _classify_impact(self, score: float) -> str:\n        \"\"\"Classifica o nível de impacto de negócio.\"\"\"\n        if score >= 85:\n            return \"Alto Impacto 🚀\"\n        elif score >= 70:\n            return \"Bom Impacto 📈\"\n        elif score >= 55:\n            return \"Impacto Moderado ➡️\"\n        elif score >= 40:\n            return \"Baixo Impacto 📉\"\n        else:\n            return \"Impacto Mínimo 😐\"\n    \n    def _calculate_total_value(self, df: pd.DataFrame, feature_value: Dict, \n                              business_alignment: Dict) -> Dict[str, Any]:\n        \"\"\"Calcula valor total entregue.\"\"\"\n        try:\n            total_items = len(df)\n            completed_items = len(df[df['Status Categoria'] == 'Done'])\n            \n            # Calcular story points entregues\n            if 'Story Points' in df.columns:\n                completed_df = df[df['Status Categoria'] == 'Done']\n                total_sp = df[df['Story Points'].notna()]['Story Points'].sum()\n                completed_sp = completed_df[completed_df['Story Points'].notna()]['Story Points'].sum()\n            else:\n                total_sp = 0\n                completed_sp = 0\n            \n            # Valor ponderado baseado nos componentes\n            high_value_items = feature_value.get('value_classification', {}).get('high_value', 0)\n            aligned_items = business_alignment.get('aligned_items', 0)\n            \n            value_score = (\n                (high_value_items / total_items * 40) +     # 40% peso para features valiosas\n                (aligned_items / total_items * 35) +        # 35% peso para alinhamento\n                (completed_items / total_items * 25)        # 25% peso para entrega\n            ) if total_items > 0 else 0\n            \n            return {\n                'total_items': total_items,\n                'completed_items': completed_items,\n                'completion_rate': round(completed_items / total_items, 2) if total_items > 0 else 0,\n                'total_story_points': total_sp,\n                'completed_story_points': completed_sp,\n                'high_value_items': high_value_items,\n                'aligned_items': aligned_items,\n                'value_score': round(value_score, 1)\n            }\n            \n        except Exception:\n            return {\n                'total_items': 0, 'completed_items': 0, 'completion_rate': 0,\n                'total_story_points': 0, 'completed_story_points': 0,\n                'high_value_items': 0, 'aligned_items': 0, 'value_score': 0\n            }\n    \n    def _identify_key_contributions(self, df: pd.DataFrame, feature_value: Dict) -> List[Dict[str, Any]]:\n        \"\"\"Identifica principais contribuições da sprint.\"\"\"\n        contributions = []\n        \n        try:\n            # Itens de alto valor\n            high_value_items = feature_value.get('high_value_items', [])\n            for item in high_value_items[:3]:\n                contributions.append({\n                    'type': 'high_value_feature',\n                    'title': item,\n                    'description': 'Funcionalidade de alto valor de negócio',\n                    'impact': 'Alto'\n                })\n            \n            # Itens com maior story points (assumindo maior esforço/valor)\n            if 'Story Points' in df.columns:\n                large_items = df[df['Story Points'].notna()].nlargest(2, 'Story Points')\n                for _, item in large_items.iterrows():\n                    contributions.append({\n                        'type': 'high_effort_item',\n                        'title': item.get('Título', 'Item sem título'),\n                        'description': f\"Item de grande esforço ({item.get('Story Points', 0)} SP)\",\n                        'impact': 'Médio'\n                    })\n            \n            # Itens relacionados a bugs críticos\n            if 'Prioridade' in df.columns:\n                critical_items = df[df['Prioridade'].str.contains('crítico|critical|high', \n                                                               case=False, na=False)]\n                for _, item in critical_items.head(2).iterrows():\n                    contributions.append({\n                        'type': 'critical_fix',\n                        'title': item.get('Título', 'Item sem título'),\n                        'description': 'Correção crítica para o negócio',\n                        'impact': 'Alto'\n                    })\n            \n        except Exception:\n            pass\n        \n        return contributions[:5]  # Limitar a 5 contribuições\n    \n    def _generate_business_insights(self, feature_value: Dict, business_alignment: Dict,\n                                   user_impact: Dict) -> List[str]:\n        \"\"\"Gera insights de negócio.\"\"\"\n        insights = []\n        \n        # Insights sobre valor das features\n        high_value_ratio = feature_value.get('high_value_ratio', 0)\n        if high_value_ratio >= 0.4:\n            insights.append(\"💎 Sprint focada em funcionalidades de alto valor\")\n        elif high_value_ratio < 0.1:\n            insights.append(\"⚠️ Poucas funcionalidades de alto valor entregues\")\n        \n        # Insights sobre alinhamento\n        alignment_ratio = business_alignment.get('alignment_ratio', 0)\n        if alignment_ratio >= 0.6:\n            insights.append(\"🎯 Excelente alinhamento com objetivos estratégicos\")\n        elif alignment_ratio < 0.3:\n            insights.append(\"📊 Baixo alinhamento com estratégia de negócio\")\n        \n        # Insights sobre impacto no usuário\n        user_ratio = user_impact.get('user_impact_ratio', 0)\n        if user_ratio >= 0.5:\n            insights.append(\"👥 Alto foco na experiência do usuário\")\n        elif user_ratio < 0.2:\n            insights.append(\"🔧 Sprint focada em melhorias internas\")\n        \n        # Insights combinados\n        if high_value_ratio >= 0.3 and alignment_ratio >= 0.5:\n            insights.append(\"🚀 Combinação ideal: alto valor + alinhamento estratégico\")\n        \n        return insights[:4]  # Limitar a 4 insights\n    \n    def _generate_strategic_recommendations(self, feature_value: Dict, business_alignment: Dict,\n                                          roi_potential: Dict) -> List[str]:\n        \"\"\"Gera recomendações estratégicas.\"\"\"\n        recommendations = []\n        \n        # Recomendações baseadas em valor\n        high_value_ratio = feature_value.get('high_value_ratio', 0)\n        if high_value_ratio < 0.3:\n            recommendations.extend([\n                \"💰 Priorizar features que geram mais valor de negócio\",\n                \"📈 Revisar backlog focando em ROI e impacto\"\n            ])\n        \n        # Recomendações baseadas em alinhamento\n        alignment_ratio = business_alignment.get('alignment_ratio', 0)\n        if alignment_ratio < 0.4:\n            recommendations.extend([\n                \"🎯 Melhorar comunicação entre negócio e desenvolvimento\",\n                \"📋 Revisar critérios de priorização do backlog\"\n            ])\n        \n        # Recomendações baseadas em ROI\n        roi_ratio = roi_potential.get('roi_items_ratio', 0)\n        if roi_ratio < 0.2:\n            recommendations.extend([\n                \"💹 Incluir mais iniciativas com potencial de ROI\",\n                \"📊 Implementar métricas de impacto financeiro\"\n            ])\n        \n        # Recomendações gerais\n        recommendations.extend([\n            \"🔄 Implementar feedback loops com stakeholders\",\n            \"📈 Medir impacto real das features entregues\"\n        ])\n        \n        return recommendations[:5]  # Limitar a 5 recomendações\n    \n    def _analyze_value_distribution(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa distribuição de valor por categorias.\"\"\"\n        try:\n            distribution = {\n                'by_type': {},\n                'by_priority': {},\n                'by_story_points': {}\n            }\n            \n            # Distribuição por tipo\n            if 'Tipo' in df.columns:\n                type_counts = df['Tipo'].value_counts().to_dict()\n                distribution['by_type'] = type_counts\n            \n            # Distribuição por prioridade\n            if 'Prioridade' in df.columns:\n                priority_counts = df['Prioridade'].value_counts().to_dict()\n                distribution['by_priority'] = priority_counts\n            \n            # Distribuição por story points\n            if 'Story Points' in df.columns:\n                sp_data = df[df['Story Points'].notna()]\n                if len(sp_data) > 0:\n                    distribution['by_story_points'] = {\n                        'small': len(sp_data[sp_data['Story Points'] <= 3]),\n                        'medium': len(sp_data[(sp_data['Story Points'] > 3) & (sp_data['Story Points'] <= 8)]),\n                        'large': len(sp_data[sp_data['Story Points'] > 8])\n                    }\n            \n            return distribution\n            \n        except Exception:\n            return {'by_type': {}, 'by_priority': {}, 'by_story_points': {}}\n    \n    def _calculate_impact_metrics(self, df: pd.DataFrame, impact_score: float) -> Dict[str, Any]:\n        \"\"\"Calcula métricas de impacto.\"\"\"\n        try:\n            total_items = len(df)\n            completed_items = len(df[df['Status Categoria'] == 'Done'])\n            \n            # Velocity baseada em story points\n            velocity = 0\n            if 'Story Points' in df.columns:\n                completed_df = df[df['Status Categoria'] == 'Done']\n                velocity = completed_df[completed_df['Story Points'].notna()]['Story Points'].sum()\n            \n            # Value per story point\n            value_per_sp = impact_score / velocity if velocity > 0 else 0\n            \n            # Efficiency ratio\n            efficiency = (impact_score / 100) * (completed_items / total_items) if total_items > 0 else 0\n            \n            return {\n                'velocity': velocity,\n                'value_per_story_point': round(value_per_sp, 2),\n                'delivery_efficiency': round(efficiency, 2),\n                'impact_per_item': round(impact_score / total_items, 2) if total_items > 0 else 0\n            }\n            \n        except Exception:\n            return {\n                'velocity': 0,\n                'value_per_story_point': 0,\n                'delivery_efficiency': 0,\n                'impact_per_item': 0\n            }\n    \n    # Métodos de interpretação\n    def _interpret_feature_value(self, score: float, high_value_ratio: float) -> str:\n        \"\"\"Interpreta score de valor das features.\"\"\"\n        if score >= 80:\n            return f\"Excelente foco em features valiosas ({high_value_ratio:.1%} alto valor)\"\n        elif score >= 60:\n            return f\"Bom mix de features ({high_value_ratio:.1%} alto valor)\"\n        else:\n            return f\"Baixo valor de negócio ({high_value_ratio:.1%} alto valor)\"\n    \n    def _interpret_business_alignment(self, score: float, alignment_ratio: float) -> str:\n        \"\"\"Interpreta score de alinhamento de negócio.\"\"\"\n        if score >= 80:\n            return f\"Forte alinhamento estratégico ({alignment_ratio:.1%} alinhado)\"\n        elif score >= 60:\n            return f\"Alinhamento moderado ({alignment_ratio:.1%} alinhado)\"\n        else:\n            return f\"Baixo alinhamento estratégico ({alignment_ratio:.1%} alinhado)\"\n    \n    def _interpret_user_impact(self, score: float, user_ratio: float) -> str:\n        \"\"\"Interpreta score de impacto no usuário.\"\"\"\n        if score >= 75:\n            return f\"Alto impacto no usuário ({user_ratio:.1%} user-facing)\"\n        elif score >= 50:\n            return f\"Impacto moderado no usuário ({user_ratio:.1%} user-facing)\"\n        else:\n            return f\"Baixo impacto no usuário ({user_ratio:.1%} user-facing)\"\n    \n    def _interpret_roi_potential(self, score: float, roi_ratio: float) -> str:\n        \"\"\"Interpreta score de potencial de ROI.\"\"\"\n        if score >= 75:\n            return f\"Alto potencial de ROI ({roi_ratio:.1%} com potencial)\"\n        elif score >= 50:\n            return f\"Potencial moderado de ROI ({roi_ratio:.1%} com potencial)\"\n        else:\n            return f\"Baixo potencial de ROI ({roi_ratio:.1%} com potencial)\"\n    \n    def _interpret_risk_reduction(self, score: float, risk_ratio: float) -> str:\n        \"\"\"Interpreta score de redução de riscos.\"\"\"\n        if score >= 75:\n            return f\"Boa redução de riscos ({risk_ratio:.1%} reduz riscos)\"\n        elif score >= 55:\n            return f\"Redução moderada de riscos ({risk_ratio:.1%} reduz riscos)\"\n        else:\n            return f\"Baixa redução de riscos ({risk_ratio:.1%} reduz riscos)\"\n    \n    def _get_default_result(self) -> Dict[str, Any]:\n        \"\"\"Retorna resultado padrão quando não há dados suficientes.\"\"\"\n        return {\n            'impact_score': 50.0,\n            'impact_level': \"Impacto Moderado ➡️\",\n            'components': {\n                'feature_value': self._get_default_component(),\n                'business_alignment': self._get_default_component(),\n                'user_impact': self._get_default_component(),\n                'roi_potential': self._get_default_component(),\n                'risk_reduction': self._get_default_component()\n            },\n            'total_value': {\n                'total_items': 0, 'completed_items': 0, 'completion_rate': 0,\n                'total_story_points': 0, 'completed_story_points': 0,\n                'high_value_items': 0, 'aligned_items': 0, 'value_score': 0\n            },\n            'key_contributions': [],\n            'business_insights': [\"Dados insuficientes para análise detalhada\"],\n            'strategic_recommendations': [\"Coletar mais dados para análise precisa\"],\n            'value_distribution': {'by_type': {}, 'by_priority': {}, 'by_story_points': {}},\n            'impact_metrics': {\n                'velocity': 0, 'value_per_story_point': 0,\n                'delivery_efficiency': 0, 'impact_per_item': 0\n            }\n        }\n    \n    def _get_default_component(self) -> Dict[str, Any]:\n        \"\"\"Retorna componente padrão.\"\"\"\n        return {\n            'score': 50.0,\n            'interpretation': 'Dados insuficientes para análise'\n        }\n    \n    def create_impact_overview_chart(self, business_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gráfico de overview do impacto de negócio.\"\"\"\n        try:\n            components = business_data['components']\n            \n            categories = ['Valor Features', 'Alinhamento', 'Impacto Usuário', 'Potencial ROI', 'Redução Risco']\n            scores = [\n                components['feature_value']['score'],\n                components['business_alignment']['score'],\n                components['user_impact']['score'],\n                components['roi_potential']['score'],\n                components['risk_reduction']['score']\n            ]\n            \n            # Cores baseadas nos scores\n            colors = []\n            for score in scores:\n                if score >= 80:\n                    colors.append('#28a745')  # Verde\n                elif score >= 60:\n                    colors.append('#ffc107')  # Amarelo\n                else:\n                    colors.append('#dc3545')  # Vermelho\n            \n            fig = go.Figure()\n            \n            fig.add_trace(go.Bar(\n                x=categories,\n                y=scores,\n                marker_color=colors,\n                text=[f'{s:.0f}' for s in scores],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Score: %{y:.1f}<extra></extra>'\n            ))\n            \n            # Linha de excelência (80)\n            fig.add_hline(y=80, line_dash=\"dash\", line_color=\"green\",\n                         annotation_text=\"Nível de Excelência (80)\")\n            \n            fig.update_layout(\n                title=f\"Impacto de Negócio - Score Geral: {business_data['impact_score']:.1f} ({business_data['impact_level']})\",\n                xaxis_title=\"Componentes\",\n                yaxis_title=\"Score\",\n                yaxis=dict(range=[0, 100]),\n                showlegend=False\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gráfico de impacto: {e}\")\n            return go.Figure()\n    \n    def create_value_distribution_chart(self, business_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gráfico de distribuição de valor.\"\"\"\n        try:\n            value_distribution = business_data['value_distribution']\n            \n            # Criar subplots para diferentes distribuições\n            fig = make_subplots(\n                rows=1, cols=3,\n                subplot_titles=('Por Tipo', 'Por Prioridade', 'Por Story Points'),\n                specs=[[{\"type\": \"pie\"}, {\"type\": \"pie\"}, {\"type\": \"pie\"}]]\n            )\n            \n            # Distribuição por tipo\n            by_type = value_distribution.get('by_type', {})\n            if by_type:\n                fig.add_trace(\n                    go.Pie(\n                        labels=list(by_type.keys()),\n                        values=list(by_type.values()),\n                        name=\"Tipo\"\n                    ),\n                    row=1, col=1\n                )\n            \n            # Distribuição por prioridade\n            by_priority = value_distribution.get('by_priority', {})\n            if by_priority:\n                fig.add_trace(\n                    go.Pie(\n                        labels=list(by_priority.keys()),\n                        values=list(by_priority.values()),\n                        name=\"Prioridade\"\n                    ),\n                    row=1, col=2\n                )\n            \n            # Distribuição por story points\n            by_sp = value_distribution.get('by_story_points', {})\n            if by_sp:\n                fig.add_trace(\n                    go.Pie(\n                        labels=['Pequeno (≤3)', 'Médio (4-8)', 'Grande (>8)'],\n                        values=[by_sp.get('small', 0), by_sp.get('medium', 0), by_sp.get('large', 0)],\n                        name=\"Story Points\"\n                    ),\n                    row=1, col=3\n                )\n            \n            fig.update_layout(\n                title=\"Distribuição de Valor Entregue\",\n                showlegend=True\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gráfico de distribuição: {e}\")\n            return go.Figure()"