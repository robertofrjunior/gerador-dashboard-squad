"""
Indicador de √çndice de Felicidade da Equipe - Analisa padr√µes que indicam satisfa√ß√£o.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

from ..utils.log import info, warn, error


class TeamHappinessIndicator:
    """
    Calcula √≠ndice de felicidade baseado em indicadores indiretos:
    - Padr√£o de entrega (consist√™ncia)
    - Overhead de reuni√µes/mudan√ßas
    - Tempo de ciclo das tarefas
    - Distribui√ß√£o de carga de trabalho
    - Frequ√™ncia de retrabalho
    """
    
    def __init__(self):
        """Inicializa o indicador de felicidade da equipe."""
        self.happiness_factors = {
            'delivery_consistency': 0.25,    # 25% - Entregas consistentes
            'workload_balance': 0.25,        # 25% - Carga balanceada
            'cycle_time_health': 0.20,       # 20% - Tempos saud√°veis
            'change_overhead': 0.15,         # 15% - Poucas mudan√ßas
            'rework_frequency': 0.15         # 15% - Baixo retrabalho
        }
    
    def calculate_happiness_index(self, df: pd.DataFrame, sprint_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Calcula o √≠ndice de felicidade da equipe.
        
        Args:
            df: DataFrame com dados dos itens da sprint
            sprint_data: Dados adicionais da sprint
            
        Returns:
            Dicion√°rio com an√°lise completa de felicidade
        """
        try:
            info("Calculando √≠ndice de felicidade da equipe...")
            
            if df.empty:
                return self._get_default_result()
            
            # 1. An√°lise de consist√™ncia de entrega
            delivery_consistency = self._analyze_delivery_consistency(df, sprint_data)
            
            # 2. An√°lise de balanceamento de carga
            workload_balance = self._analyze_workload_balance(df)
            
            # 3. An√°lise de sa√∫de dos tempos de ciclo
            cycle_time_health = self._analyze_cycle_time_health(df)
            
            # 4. An√°lise de overhead de mudan√ßas
            change_overhead = self._analyze_change_overhead(df, sprint_data)
            
            # 5. An√°lise de frequ√™ncia de retrabalho
            rework_frequency = self._analyze_rework_frequency(df)
            
            # Calcular √≠ndice final
            happiness_index = (
                delivery_consistency['score'] * self.happiness_factors['delivery_consistency'] +
                workload_balance['score'] * self.happiness_factors['workload_balance'] +
                cycle_time_health['score'] * self.happiness_factors['cycle_time_health'] +
                change_overhead['score'] * self.happiness_factors['change_overhead'] +
                rework_frequency['score'] * self.happiness_factors['rework_frequency']
            )
            
            # Classificar felicidade
            happiness_level = self._classify_happiness(happiness_index)
            
            # Identificar fatores de estresse
            stress_factors = self._identify_stress_factors(\n                delivery_consistency, workload_balance, cycle_time_health,\n                change_overhead, rework_frequency\n            )
            
            # Gerar recomenda√ß√µes de bem-estar
            wellness_recommendations = self._generate_wellness_recommendations(stress_factors)
            
            result = {\n                'happiness_index': round(happiness_index, 1),\n                'happiness_level': happiness_level,\n                'factors': {\n                    'delivery_consistency': delivery_consistency,\n                    'workload_balance': workload_balance,\n                    'cycle_time_health': cycle_time_health,\n                    'change_overhead': change_overhead,\n                    'rework_frequency': rework_frequency\n                },\n                'stress_factors': stress_factors,\n                'wellness_recommendations': wellness_recommendations,\n                'team_insights': self._generate_team_insights(\n                    delivery_consistency, workload_balance, cycle_time_health\n                ),\n                'burnout_risk': self._assess_burnout_risk(\n                    workload_balance, cycle_time_health, change_overhead\n                )\n            }\n            \n            info(f\"√çndice de felicidade: {happiness_index:.1f} ({happiness_level})\")\n            return result\n            \n        except Exception as e:\n            error(f\"Erro ao calcular √≠ndice de felicidade: {e}\")\n            return self._get_default_result()\n    \n    def _analyze_delivery_consistency(self, df: pd.DataFrame, \n                                     sprint_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Analisa consist√™ncia na entrega ao longo do tempo.\"\"\"\n        try:\n            # Analisar padr√£o de conclus√£o das tarefas\n            if 'Data Resolu√ß√£o' not in df.columns:\n                return {'score': 70.0, 'level': 'Moderada', 'details': 'Dados insuficientes'}\n            \n            completed_df = df[df['Status Categoria'] == 'Done'].copy()\n            \n            if len(completed_df) < 3:\n                return {'score': 50.0, 'level': 'Baixa', 'details': 'Poucas entregas para an√°lise'}\n            \n            # Converter datas\n            completed_df['Data Resolu√ß√£o'] = pd.to_datetime(\n                completed_df['Data Resolu√ß√£o'], errors='coerce'\n            )\n            \n            # Analisar distribui√ß√£o das entregas ao longo da sprint\n            sprint_start = sprint_data.get('start_date')\n            sprint_end = sprint_data.get('end_date')\n            \n            if sprint_start and sprint_end:\n                if isinstance(sprint_start, str):\n                    sprint_start = datetime.fromisoformat(sprint_start)\n                if isinstance(sprint_end, str):\n                    sprint_end = datetime.fromisoformat(sprint_end)\n                \n                sprint_duration = (sprint_end - sprint_start).days\n                \n                if sprint_duration > 0:\n                    # Dividir sprint em ter√ßos\n                    third = sprint_duration / 3\n                    \n                    early_end = sprint_start + timedelta(days=third)\n                    mid_end = sprint_start + timedelta(days=2*third)\n                    \n                    early_deliveries = len(completed_df[\n                        completed_df['Data Resolu√ß√£o'] <= early_end\n                    ])\n                    mid_deliveries = len(completed_df[\n                        (completed_df['Data Resolu√ß√£o'] > early_end) &\n                        (completed_df['Data Resolu√ß√£o'] <= mid_end)\n                    ])\n                    late_deliveries = len(completed_df[\n                        completed_df['Data Resolu√ß√£o'] > mid_end\n                    ])\n                    \n                    total_deliveries = len(completed_df)\n                    \n                    # Calcular score baseado na distribui√ß√£o\n                    # Idealmente: algumas entregas ao longo de toda sprint\n                    early_pct = early_deliveries / total_deliveries\n                    mid_pct = mid_deliveries / total_deliveries\n                    late_pct = late_deliveries / total_deliveries\n                    \n                    # Penalizar entregas muito concentradas no final\n                    if late_pct > 0.8:  # >80% no final\n                        score = 30\n                        level = 'Baixa'\n                        details = f'Entregas concentradas no final ({late_pct:.1%})'\n                    elif late_pct > 0.6:  # >60% no final\n                        score = 50\n                        level = 'Moderada'\n                        details = f'Muitas entregas no final ({late_pct:.1%})'\n                    elif early_pct > 0.7:  # >70% no in√≠cio (pode indicar subestima√ß√£o)\n                        score = 75\n                        level = 'Boa'\n                        details = f'Entregas concentradas no in√≠cio ({early_pct:.1%})'\n                    else:  # Distribui√ß√£o balanceada\n                        score = 90\n                        level = 'Excelente'\n                        details = f'Entregas bem distribu√≠das (in√≠cio: {early_pct:.1%}, meio: {mid_pct:.1%}, fim: {late_pct:.1%})'\n                    \n                    return {\n                        'score': score,\n                        'level': level,\n                        'details': details,\n                        'distribution': {\n                            'early': early_pct,\n                            'mid': mid_pct,\n                            'late': late_pct\n                        }\n                    }\n            \n            return {'score': 70.0, 'level': 'Moderada', 'details': 'Dados de data insuficientes'}\n            \n        except Exception:\n            return {'score': 60.0, 'level': 'Moderada', 'details': 'Erro na an√°lise'}\n    \n    def _analyze_workload_balance(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa balanceamento da carga de trabalho.\"\"\"\n        try:\n            if 'Respons√°vel' not in df.columns:\n                return {'score': 60.0, 'level': 'Moderado', 'details': 'Sem dados de respons√°vel'}\n            \n            # Limpar dados de respons√°veis\n            df_clean = df[df['Respons√°vel'].notna()].copy()\n            df_clean = df_clean[df_clean['Respons√°vel'].str.strip() != '']\n            \n            if len(df_clean) == 0:\n                return {'score': 50.0, 'level': 'Baixo', 'details': 'Sem respons√°veis definidos'}\n            \n            # Calcular distribui√ß√£o de itens por pessoa\n            assignee_counts = df_clean['Respons√°vel'].value_counts()\n            \n            if len(assignee_counts) == 1:\n                return {'score': 40.0, 'level': 'Baixo', 'details': 'Apenas uma pessoa trabalhando'}\n            \n            # Calcular coeficiente de varia√ß√£o (desvio/m√©dia)\n            mean_items = assignee_counts.mean()\n            std_items = assignee_counts.std()\n            \n            if mean_items == 0:\n                cv = 0\n            else:\n                cv = std_items / mean_items\n            \n            # Score baseado no coeficiente de varia√ß√£o\n            if cv <= 0.2:  # Muito bem balanceado\n                score = 95\n                level = 'Excelente'\n            elif cv <= 0.4:  # Bem balanceado\n                score = 85\n                level = 'Bom'\n            elif cv <= 0.6:  # Moderadamente balanceado\n                score = 70\n                level = 'Moderado'\n            elif cv <= 0.8:  # Desbalanceado\n                score = 50\n                level = 'Baixo'\n            else:  # Muito desbalanceado\n                score = 30\n                level = 'Cr√≠tico'\n            \n            max_items = assignee_counts.max()\n            min_items = assignee_counts.min()\n            \n            return {\n                'score': score,\n                'level': level,\n                'details': f'CV: {cv:.2f}, M√°x: {max_items}, M√≠n: {min_items}',\n                'coefficient_variation': cv,\n                'distribution': assignee_counts.to_dict(),\n                'max_workload': max_items,\n                'min_workload': min_items\n            }\n            \n        except Exception:\n            return {'score': 60.0, 'level': 'Moderado', 'details': 'Erro na an√°lise'}\n    \n    def _analyze_cycle_time_health(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa sa√∫de dos tempos de ciclo.\"\"\"\n        try:\n            if 'Dias para Resolu√ß√£o' not in df.columns:\n                return {'score': 65.0, 'level': 'Moderado', 'details': 'Sem dados de tempo'}\n            \n            completed_df = df[\n                (df['Status Categoria'] == 'Done') &\n                (df['Dias para Resolu√ß√£o'].notna()) &\n                (df['Dias para Resolu√ß√£o'] > 0)\n            ].copy()\n            \n            if len(completed_df) < 3:\n                return {'score': 50.0, 'level': 'Baixo', 'details': 'Poucos itens completos'}\n            \n            cycle_times = completed_df['Dias para Resolu√ß√£o']\n            \n            mean_cycle_time = cycle_times.mean()\n            median_cycle_time = cycle_times.median()\n            std_cycle_time = cycle_times.std()\n            \n            # Detectar outliers (tempos muito longos)\n            q75 = cycle_times.quantile(0.75)\n            q25 = cycle_times.quantile(0.25)\n            iqr = q75 - q25\n            upper_bound = q75 + 1.5 * iqr\n            \n            outliers = cycle_times[cycle_times > upper_bound]\n            outlier_ratio = len(outliers) / len(cycle_times)\n            \n            # Score baseado na sa√∫de dos tempos\n            score = 80  # Score base\n            \n            # Penalizar outliers excessivos\n            if outlier_ratio > 0.3:  # >30% outliers\n                score -= 30\n                health_issue = \"Muitos itens com tempo excessivo\"\n            elif outlier_ratio > 0.2:  # >20% outliers\n                score -= 20\n                health_issue = \"Alguns itens com tempo elevado\"\n            elif outlier_ratio > 0.1:  # >10% outliers\n                score -= 10\n                health_issue = \"Poucos itens com tempo elevado\"\n            else:\n                health_issue = \"Tempos consistentes\"\n            \n            # Penalizar variabilidade excessiva\n            if std_cycle_time > mean_cycle_time:  # Desvio > m√©dia\n                score -= 15\n                health_issue += \", alta variabilidade\"\n            \n            # Penalizar tempos m√©dios muito altos\n            if mean_cycle_time > 10:  # >10 dias em m√©dia\n                score -= 20\n                health_issue += \", tempos muito longos\"\n            elif mean_cycle_time > 7:  # >7 dias\n                score -= 10\n                health_issue += \", tempos longos\"\n            \n            score = max(20, score)  # M√≠nimo de 20\n            \n            if score >= 80:\n                level = 'Excelente'\n            elif score >= 65:\n                level = 'Bom'\n            elif score >= 50:\n                level = 'Moderado'\n            elif score >= 35:\n                level = 'Baixo'\n            else:\n                level = 'Cr√≠tico'\n            \n            return {\n                'score': score,\n                'level': level,\n                'details': health_issue,\n                'mean_cycle_time': round(mean_cycle_time, 1),\n                'median_cycle_time': round(median_cycle_time, 1),\n                'std_cycle_time': round(std_cycle_time, 1),\n                'outlier_ratio': round(outlier_ratio, 2),\n                'outliers_count': len(outliers)\n            }\n            \n        except Exception:\n            return {'score': 60.0, 'level': 'Moderado', 'details': 'Erro na an√°lise'}\n    \n    def _analyze_change_overhead(self, df: pd.DataFrame, \n                                sprint_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Analisa overhead causado por mudan√ßas.\"\"\"\n        try:\n            # Analisar mudan√ßas de status, prioridade, etc.\n            changes_detected = 0\n            total_changes = 0\n            \n            # Contar mudan√ßas de prioridade (se dispon√≠vel)\n            if 'Prioridade' in df.columns:\n                priority_changes = df['Prioridade'].value_counts()\n                if len(priority_changes) > 1:\n                    total_changes += len(df)\n            \n            # Contar mudan√ßas de respons√°vel\n            if 'Respons√°vel' in df.columns:\n                # Assumir que itens com m√∫ltiplos respons√°veis tiveram mudan√ßa\n                multiple_assignees = df[df['Respons√°vel'].str.contains(',|;', na=False)]\n                changes_detected += len(multiple_assignees)\n                total_changes += len(df)\n            \n            # Analisar itens adicionados durante a sprint\n            sprint_start = sprint_data.get('start_date')\n            if sprint_start and 'Data Cria√ß√£o' in df.columns:\n                if isinstance(sprint_start, str):\n                    sprint_start = datetime.fromisoformat(sprint_start)\n                \n                df_temp = df.copy()\n                df_temp['Data Cria√ß√£o'] = pd.to_datetime(df_temp['Data Cria√ß√£o'], errors='coerce')\n                \n                items_added_during = len(df_temp[df_temp['Data Cria√ß√£o'] > sprint_start])\n                changes_detected += items_added_during\n                total_changes += len(df)\n            \n            if total_changes == 0:\n                change_ratio = 0\n            else:\n                change_ratio = changes_detected / total_changes\n            \n            # Score baseado na quantidade de mudan√ßas\n            if change_ratio <= 0.1:  # <=10% mudan√ßas\n                score = 90\n                level = 'Baixo'\n            elif change_ratio <= 0.2:  # <=20% mudan√ßas\n                score = 75\n                level = 'Moderado'\n            elif change_ratio <= 0.3:  # <=30% mudan√ßas\n                score = 60\n                level = 'Alto'\n            else:  # >30% mudan√ßas\n                score = 40\n                level = 'Cr√≠tico'\n            \n            return {\n                'score': score,\n                'level': level,\n                'details': f'{change_ratio:.1%} de itens com mudan√ßas',\n                'change_ratio': change_ratio,\n                'changes_detected': changes_detected,\n                'total_items': total_changes\n            }\n            \n        except Exception:\n            return {'score': 70.0, 'level': 'Moderado', 'details': 'Erro na an√°lise'}\n    \n    def _analyze_rework_frequency(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa frequ√™ncia de retrabalho.\"\"\"\n        try:\n            # Detectar retrabalho atrav√©s de padr√µes\n            rework_indicators = 0\n            total_items = len(df)\n            \n            if total_items == 0:\n                return {'score': 70.0, 'level': 'Moderado', 'details': 'Sem itens'}\n            \n            # 1. Bugs relacionados a features\n            if 'Tipo' in df.columns:\n                bug_keywords = ['bug', 'defeito', 'erro', 'falha', 'corre√ß√£o']\n                df_lower = df['Tipo'].str.lower()\n                bugs = df_lower.str.contains('|'.join(bug_keywords), na=False).sum()\n                rework_indicators += bugs\n            \n            # 2. Itens que voltaram para status anterior\n            if 'Status' in df.columns:\n                # Assumir que itens em \"To Do\" ou \"In Progress\" ap√≥s terem sido \"Done\" s√£o retrabalho\n                # (n√£o podemos detectar isso facilmente com dados est√°ticos)\n                pass\n            \n            # 3. Itens com m√∫ltiplas revis√µes (se tivermos campo de coment√°rios)\n            if 'Coment√°rios' in df.columns:\n                items_with_comments = df[df['Coment√°rios'].notna()]\n                # Assumir que itens com muitos coment√°rios podem indicar retrabalho\n                rework_indicators += len(items_with_comments) * 0.3  # Peso menor\n            \n            rework_ratio = rework_indicators / total_items\n            \n            # Score baseado na frequ√™ncia de retrabalho\n            if rework_ratio <= 0.05:  # <=5% retrabalho\n                score = 95\n                level = 'Baixo'\n            elif rework_ratio <= 0.1:  # <=10% retrabalho\n                score = 80\n                level = 'Moderado'\n            elif rework_ratio <= 0.2:  # <=20% retrabalho\n                score = 60\n                level = 'Alto'\n            else:  # >20% retrabalho\n                score = 40\n                level = 'Cr√≠tico'\n            \n            return {\n                'score': score,\n                'level': level,\n                'details': f'{rework_ratio:.1%} de indicadores de retrabalho',\n                'rework_ratio': rework_ratio,\n                'rework_indicators': int(rework_indicators),\n                'total_items': total_items\n            }\n            \n        except Exception:\n            return {'score': 75.0, 'level': 'Moderado', 'details': 'Erro na an√°lise'}\n    \n    def _classify_happiness(self, index: float) -> str:\n        \"\"\"Classifica o √≠ndice de felicidade.\"\"\"\n        if index >= 85:\n            return \"Muito Feliz üòä\"\n        elif index >= 70:\n            return \"Feliz üôÇ\"\n        elif index >= 55:\n            return \"Neutro üòê\"\n        elif index >= 40:\n            return \"Insatisfeita üòï\"\n        else:\n            return \"Infeliz üòü\"\n    \n    def _identify_stress_factors(self, delivery_consistency: Dict, workload_balance: Dict,\n                                cycle_time_health: Dict, change_overhead: Dict,\n                                rework_frequency: Dict) -> List[Dict[str, Any]]:\n        \"\"\"Identifica fatores de estresse da equipe.\"\"\"\n        stress_factors = []\n        \n        # Analisar cada fator\n        factors = {\n            'Consist√™ncia de Entrega': delivery_consistency,\n            'Balanceamento de Carga': workload_balance,\n            'Sa√∫de dos Tempos': cycle_time_health,\n            'Overhead de Mudan√ßas': change_overhead,\n            'Frequ√™ncia de Retrabalho': rework_frequency\n        }\n        \n        for factor_name, factor_data in factors.items():\n            score = factor_data.get('score', 70)\n            level = factor_data.get('level', 'Moderado')\n            details = factor_data.get('details', '')\n            \n            if score < 50:\n                stress_factors.append({\n                    'factor': factor_name,\n                    'severity': 'Alto',\n                    'score': score,\n                    'description': details,\n                    'impact': 'Pode causar frustra√ß√£o e desmotiva√ß√£o'\n                })\n            elif score < 65:\n                stress_factors.append({\n                    'factor': factor_name,\n                    'severity': 'M√©dio',\n                    'score': score,\n                    'description': details,\n                    'impact': 'Pode afetar a satisfa√ß√£o da equipe'\n                })\n        \n        return stress_factors\n    \n    def _generate_wellness_recommendations(self, stress_factors: List[Dict]) -> List[str]:\n        \"\"\"Gera recomenda√ß√µes para melhorar bem-estar da equipe.\"\"\"\n        recommendations = []\n        \n        # Recomenda√ß√µes baseadas nos fatores de estresse\n        stress_types = [factor['factor'] for factor in stress_factors \n                       if factor['severity'] in ['Alto', 'M√©dio']]\n        \n        if 'Balanceamento de Carga' in stress_types:\n            recommendations.extend([\n                \"‚öñÔ∏è Redistribuir tarefas para equilibrar carga de trabalho\",\n                \"ü§ù Implementar pair programming para compartilhar conhecimento\"\n            ])\n        \n        if 'Sa√∫de dos Tempos' in stress_types:\n            recommendations.extend([\n                \"‚è∞ Revisar estimativas e quebrar tarefas grandes\",\n                \"üöß Identificar e remover impedimentos que causam atrasos\"\n            ])\n        \n        if 'Overhead de Mudan√ßas' in stress_types:\n            recommendations.extend([\n                \"üìã Melhorar refinamento para reduzir mudan√ßas\",\n                \"üõ°Ô∏è Proteger a equipe de mudan√ßas de escopo frequentes\"\n            ])\n        \n        if 'Frequ√™ncia de Retrabalho' in stress_types:\n            recommendations.extend([\n                \"‚úÖ Investir em testes automatizados e code review\",\n                \"üìö Melhorar documenta√ß√£o e crit√©rios de aceita√ß√£o\"\n            ])\n        \n        if 'Consist√™ncia de Entrega' in stress_types:\n            recommendations.extend([\n                \"üìä Implementar daily standups mais efetivos\",\n                \"üéØ Focar em entregar valor incrementalmente\"\n            ])\n        \n        # Recomenda√ß√µes gerais de bem-estar\n        if len(stress_factors) > 2:\n            recommendations.extend([\n                \"üå± Considerar retrospectivas focadas em bem-estar\",\n                \"üí¨ Criar espa√ßos seguros para feedback da equipe\",\n                \"üéâ Celebrar pequenas vit√≥rias e reconhecer contribui√ß√µes\"\n            ])\n        \n        return recommendations[:6]  # Limitar a 6 recomenda√ß√µes\n    \n    def _generate_team_insights(self, delivery_consistency: Dict, workload_balance: Dict,\n                               cycle_time_health: Dict) -> List[str]:\n        \"\"\"Gera insights sobre a equipe.\"\"\"\n        insights = []\n        \n        # Insights positivos\n        if delivery_consistency.get('score', 0) >= 80:\n            insights.append(\"üöÄ Equipe demonstra boa consist√™ncia nas entregas\")\n        \n        if workload_balance.get('score', 0) >= 80:\n            insights.append(\"‚öñÔ∏è Carga de trabalho bem distribu√≠da entre membros\")\n        \n        if cycle_time_health.get('score', 0) >= 80:\n            insights.append(\"‚è±Ô∏è Tempos de ciclo saud√°veis indicam bom fluxo de trabalho\")\n        \n        # Insights de alerta\n        if delivery_consistency.get('score', 0) < 50:\n            insights.append(\"‚ö†Ô∏è Padr√£o de entregas pode indicar dificuldades no planejamento\")\n        \n        if workload_balance.get('score', 0) < 50:\n            insights.append(\"‚ö†Ô∏è Desbalanceamento pode causar sobrecarga em alguns membros\")\n        \n        return insights\n    \n    def _assess_burnout_risk(self, workload_balance: Dict, cycle_time_health: Dict,\n                            change_overhead: Dict) -> str:\n        \"\"\"Avalia risco de burnout da equipe.\"\"\"\n        risk_score = 0\n        \n        # Fatores que aumentam risco de burnout\n        if workload_balance.get('score', 70) < 50:\n            risk_score += 3  # Desbalanceamento severo\n        elif workload_balance.get('score', 70) < 65:\n            risk_score += 1  # Desbalanceamento moderado\n        \n        if cycle_time_health.get('score', 70) < 40:\n            risk_score += 3  # Tempos muito ruins\n        elif cycle_time_health.get('score', 70) < 60:\n            risk_score += 2  # Tempos ruins\n        \n        if change_overhead.get('score', 70) < 50:\n            risk_score += 2  # Muitas mudan√ßas\n        elif change_overhead.get('score', 70) < 70:\n            risk_score += 1  # Mudan√ßas moderadas\n        \n        # Classificar risco\n        if risk_score >= 6:\n            return \"Alto\"\n        elif risk_score >= 3:\n            return \"M√©dio\"\n        else:\n            return \"Baixo\"\n    \n    def _get_default_result(self) -> Dict[str, Any]:\n        \"\"\"Retorna resultado padr√£o quando n√£o h√° dados suficientes.\"\"\"\n        return {\n            'happiness_index': 60.0,\n            'happiness_level': \"Neutro üòê\",\n            'factors': {\n                'delivery_consistency': {'score': 60, 'level': 'Moderada'},\n                'workload_balance': {'score': 60, 'level': 'Moderado'},\n                'cycle_time_health': {'score': 60, 'level': 'Moderado'},\n                'change_overhead': {'score': 60, 'level': 'Moderado'},\n                'rework_frequency': {'score': 60, 'level': 'Moderado'}\n            },\n            'stress_factors': [],\n            'wellness_recommendations': [\"Coletar mais dados para an√°lise precisa\"],\n            'team_insights': [\"Dados insuficientes para insights detalhados\"],\n            'burnout_risk': \"Indeterminado\"\n        }\n    \n    def create_happiness_radar(self, happiness_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gr√°fico radar do √≠ndice de felicidade.\"\"\"\n        try:\n            factors = happiness_data['factors']\n            \n            categories = [\n                'Consist√™ncia<br>de Entrega',\n                'Balanceamento<br>de Carga', \n                'Sa√∫de dos<br>Tempos',\n                'Overhead de<br>Mudan√ßas',\n                'Frequ√™ncia de<br>Retrabalho'\n            ]\n            \n            values = [\n                factors['delivery_consistency']['score'],\n                factors['workload_balance']['score'],\n                factors['cycle_time_health']['score'],\n                factors['change_overhead']['score'],\n                factors['rework_frequency']['score']\n            ]\n            \n            # Fechar o radar\n            values.append(values[0])\n            categories.append(categories[0])\n            \n            # Cores baseadas no √≠ndice geral\n            happiness_index = happiness_data['happiness_index']\n            if happiness_index >= 70:\n                color = 'rgba(40, 167, 69, 0.3)'  # Verde\n                line_color = 'rgba(40, 167, 69, 1)'\n            elif happiness_index >= 55:\n                color = 'rgba(255, 193, 7, 0.3)'   # Amarelo\n                line_color = 'rgba(255, 193, 7, 1)'\n            else:\n                color = 'rgba(220, 53, 69, 0.3)'   # Vermelho\n                line_color = 'rgba(220, 53, 69, 1)'\n            \n            fig = go.Figure()\n            \n            fig.add_trace(go.Scatterpolar(\n                r=values,\n                theta=categories,\n                fill='toself',\n                name='Felicidade',\n                fillcolor=color,\n                line_color=line_color,\n                line_width=3\n            ))\n            \n            fig.update_layout(\n                polar=dict(\n                    radialaxis=dict(\n                        visible=True,\n                        range=[0, 100]\n                    )\n                ),\n                title=f\"Radar de Felicidade da Equipe - {happiness_data['happiness_index']:.1f} ({happiness_data['happiness_level']})\",\n                showlegend=False\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gr√°fico de felicidade: {e}\")\n            return go.Figure()\n    \n    def create_stress_factors_chart(self, happiness_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gr√°fico de fatores de estresse.\"\"\"\n        try:\n            stress_factors = happiness_data['stress_factors']\n            \n            if not stress_factors:\n                # Criar gr√°fico vazio com mensagem positiva\n                fig = go.Figure()\n                fig.add_annotation(\n                    text=\"üéâ Nenhum fator de estresse<br>significativo identificado!\",\n                    xref=\"paper\", yref=\"paper\",\n                    x=0.5, y=0.5, xanchor='center', yanchor='middle',\n                    showarrow=False,\n                    font=dict(size=16, color=\"green\")\n                )\n                fig.update_layout(\n                    title=\"Fatores de Estresse da Equipe\",\n                    xaxis=dict(visible=False),\n                    yaxis=dict(visible=False)\n                )\n                return fig\n            \n            factors = [factor['factor'] for factor in stress_factors]\n            scores = [factor['score'] for factor in stress_factors]\n            severities = [factor['severity'] for factor in stress_factors]\n            \n            # Cores baseadas na severidade\n            colors = []\n            for severity in severities:\n                if severity == 'Alto':\n                    colors.append('#dc3545')\n                elif severity == 'M√©dio':\n                    colors.append('#fd7e14')\n                else:\n                    colors.append('#ffc107')\n            \n            fig = go.Figure()\n            \n            fig.add_trace(go.Bar(\n                x=factors,\n                y=scores,\n                marker_color=colors,\n                text=[f'{s:.0f}' for s in scores],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Score: %{y}<br>Severidade: %{customdata}<extra></extra>',\n                customdata=severities\n            ))\n            \n            fig.update_layout(\n                title=\"Fatores de Estresse Identificados\",\n                xaxis_title=\"Fatores\",\n                yaxis_title=\"Score (menor = maior estresse)\",\n                yaxis=dict(range=[0, 100]),\n                showlegend=False\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gr√°fico de estresse: {e}\")\n            return go.Figure()"