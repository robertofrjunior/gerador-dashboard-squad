"""
Indicador de Índice de Felicidade da Equipe - Analisa padrões que indicam satisfação.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

from ..utils.log import info, warn, error


class TeamHappinessIndicator:
    """
    Calcula índice de felicidade baseado em indicadores indiretos:
    - Padrão de entrega (consistência)
    - Overhead de reuniões/mudanças
    - Tempo de ciclo das tarefas
    - Distribuição de carga de trabalho
    - Frequência de retrabalho
    """
    
    def __init__(self):
        """Inicializa o indicador de felicidade da equipe."""
        self.happiness_factors = {
            'delivery_consistency': 0.25,    # 25% - Entregas consistentes
            'workload_balance': 0.25,        # 25% - Carga balanceada
            'cycle_time_health': 0.20,       # 20% - Tempos saudáveis
            'change_overhead': 0.15,         # 15% - Poucas mudanças
            'rework_frequency': 0.15         # 15% - Baixo retrabalho
        }
    
    def calculate_happiness_index(self, df: pd.DataFrame, sprint_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Calcula o índice de felicidade da equipe.
        
        Args:
            df: DataFrame com dados dos itens da sprint
            sprint_data: Dados adicionais da sprint
            
        Returns:
            Dicionário com análise completa de felicidade
        """
        try:
            info("Calculando índice de felicidade da equipe...")
            
            if df.empty:
                return self._get_default_result()
            
            # 1. Análise de consistência de entrega
            delivery_consistency = self._analyze_delivery_consistency(df, sprint_data)
            
            # 2. Análise de balanceamento de carga
            workload_balance = self._analyze_workload_balance(df)
            
            # 3. Análise de saúde dos tempos de ciclo
            cycle_time_health = self._analyze_cycle_time_health(df)
            
            # 4. Análise de overhead de mudanças
            change_overhead = self._analyze_change_overhead(df, sprint_data)
            
            # 5. Análise de frequência de retrabalho
            rework_frequency = self._analyze_rework_frequency(df)
            
            # Calcular índice final
            happiness_index = (
                delivery_consistency['score'] * self.happiness_factors['delivery_consistency'] +
                workload_balance['score'] * self.happiness_factors['workload_balance'] +
                cycle_time_health['score'] * self.happiness_factors['cycle_time_health'] +
                change_overhead['score'] * self.happiness_factors['change_overhead'] +
                rework_frequency['score'] * self.happiness_factors['rework_frequency']
            )
            
            # Classificar felicidade
            happiness_level = self._classify_happiness(happiness_index)
            
            # Identificar fatores de estresse
            stress_factors = self._identify_stress_factors(\n                delivery_consistency, workload_balance, cycle_time_health,\n                change_overhead, rework_frequency\n            )
            
            # Gerar recomendações de bem-estar
            wellness_recommendations = self._generate_wellness_recommendations(stress_factors)
            
            result = {\n                'happiness_index': round(happiness_index, 1),\n                'happiness_level': happiness_level,\n                'factors': {\n                    'delivery_consistency': delivery_consistency,\n                    'workload_balance': workload_balance,\n                    'cycle_time_health': cycle_time_health,\n                    'change_overhead': change_overhead,\n                    'rework_frequency': rework_frequency\n                },\n                'stress_factors': stress_factors,\n                'wellness_recommendations': wellness_recommendations,\n                'team_insights': self._generate_team_insights(\n                    delivery_consistency, workload_balance, cycle_time_health\n                ),\n                'burnout_risk': self._assess_burnout_risk(\n                    workload_balance, cycle_time_health, change_overhead\n                )\n            }\n            \n            info(f\"Índice de felicidade: {happiness_index:.1f} ({happiness_level})\")\n            return result\n            \n        except Exception as e:\n            error(f\"Erro ao calcular índice de felicidade: {e}\")\n            return self._get_default_result()\n    \n    def _analyze_delivery_consistency(self, df: pd.DataFrame, \n                                     sprint_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Analisa consistência na entrega ao longo do tempo.\"\"\"\n        try:\n            # Analisar padrão de conclusão das tarefas\n            if 'Data Resolução' not in df.columns:\n                return {'score': 70.0, 'level': 'Moderada', 'details': 'Dados insuficientes'}\n            \n            completed_df = df[df['Status Categoria'] == 'Done'].copy()\n            \n            if len(completed_df) < 3:\n                return {'score': 50.0, 'level': 'Baixa', 'details': 'Poucas entregas para análise'}\n            \n            # Converter datas\n            completed_df['Data Resolução'] = pd.to_datetime(\n                completed_df['Data Resolução'], errors='coerce'\n            )\n            \n            # Analisar distribuição das entregas ao longo da sprint\n            sprint_start = sprint_data.get('start_date')\n            sprint_end = sprint_data.get('end_date')\n            \n            if sprint_start and sprint_end:\n                if isinstance(sprint_start, str):\n                    sprint_start = datetime.fromisoformat(sprint_start)\n                if isinstance(sprint_end, str):\n                    sprint_end = datetime.fromisoformat(sprint_end)\n                \n                sprint_duration = (sprint_end - sprint_start).days\n                \n                if sprint_duration > 0:\n                    # Dividir sprint em terços\n                    third = sprint_duration / 3\n                    \n                    early_end = sprint_start + timedelta(days=third)\n                    mid_end = sprint_start + timedelta(days=2*third)\n                    \n                    early_deliveries = len(completed_df[\n                        completed_df['Data Resolução'] <= early_end\n                    ])\n                    mid_deliveries = len(completed_df[\n                        (completed_df['Data Resolução'] > early_end) &\n                        (completed_df['Data Resolução'] <= mid_end)\n                    ])\n                    late_deliveries = len(completed_df[\n                        completed_df['Data Resolução'] > mid_end\n                    ])\n                    \n                    total_deliveries = len(completed_df)\n                    \n                    # Calcular score baseado na distribuição\n                    # Idealmente: algumas entregas ao longo de toda sprint\n                    early_pct = early_deliveries / total_deliveries\n                    mid_pct = mid_deliveries / total_deliveries\n                    late_pct = late_deliveries / total_deliveries\n                    \n                    # Penalizar entregas muito concentradas no final\n                    if late_pct > 0.8:  # >80% no final\n                        score = 30\n                        level = 'Baixa'\n                        details = f'Entregas concentradas no final ({late_pct:.1%})'\n                    elif late_pct > 0.6:  # >60% no final\n                        score = 50\n                        level = 'Moderada'\n                        details = f'Muitas entregas no final ({late_pct:.1%})'\n                    elif early_pct > 0.7:  # >70% no início (pode indicar subestimação)\n                        score = 75\n                        level = 'Boa'\n                        details = f'Entregas concentradas no início ({early_pct:.1%})'\n                    else:  # Distribuição balanceada\n                        score = 90\n                        level = 'Excelente'\n                        details = f'Entregas bem distribuídas (início: {early_pct:.1%}, meio: {mid_pct:.1%}, fim: {late_pct:.1%})'\n                    \n                    return {\n                        'score': score,\n                        'level': level,\n                        'details': details,\n                        'distribution': {\n                            'early': early_pct,\n                            'mid': mid_pct,\n                            'late': late_pct\n                        }\n                    }\n            \n            return {'score': 70.0, 'level': 'Moderada', 'details': 'Dados de data insuficientes'}\n            \n        except Exception:\n            return {'score': 60.0, 'level': 'Moderada', 'details': 'Erro na análise'}\n    \n    def _analyze_workload_balance(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa balanceamento da carga de trabalho.\"\"\"\n        try:\n            if 'Responsável' not in df.columns:\n                return {'score': 60.0, 'level': 'Moderado', 'details': 'Sem dados de responsável'}\n            \n            # Limpar dados de responsáveis\n            df_clean = df[df['Responsável'].notna()].copy()\n            df_clean = df_clean[df_clean['Responsável'].str.strip() != '']\n            \n            if len(df_clean) == 0:\n                return {'score': 50.0, 'level': 'Baixo', 'details': 'Sem responsáveis definidos'}\n            \n            # Calcular distribuição de itens por pessoa\n            assignee_counts = df_clean['Responsável'].value_counts()\n            \n            if len(assignee_counts) == 1:\n                return {'score': 40.0, 'level': 'Baixo', 'details': 'Apenas uma pessoa trabalhando'}\n            \n            # Calcular coeficiente de variação (desvio/média)\n            mean_items = assignee_counts.mean()\n            std_items = assignee_counts.std()\n            \n            if mean_items == 0:\n                cv = 0\n            else:\n                cv = std_items / mean_items\n            \n            # Score baseado no coeficiente de variação\n            if cv <= 0.2:  # Muito bem balanceado\n                score = 95\n                level = 'Excelente'\n            elif cv <= 0.4:  # Bem balanceado\n                score = 85\n                level = 'Bom'\n            elif cv <= 0.6:  # Moderadamente balanceado\n                score = 70\n                level = 'Moderado'\n            elif cv <= 0.8:  # Desbalanceado\n                score = 50\n                level = 'Baixo'\n            else:  # Muito desbalanceado\n                score = 30\n                level = 'Crítico'\n            \n            max_items = assignee_counts.max()\n            min_items = assignee_counts.min()\n            \n            return {\n                'score': score,\n                'level': level,\n                'details': f'CV: {cv:.2f}, Máx: {max_items}, Mín: {min_items}',\n                'coefficient_variation': cv,\n                'distribution': assignee_counts.to_dict(),\n                'max_workload': max_items,\n                'min_workload': min_items\n            }\n            \n        except Exception:\n            return {'score': 60.0, 'level': 'Moderado', 'details': 'Erro na análise'}\n    \n    def _analyze_cycle_time_health(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa saúde dos tempos de ciclo.\"\"\"\n        try:\n            if 'Dias para Resolução' not in df.columns:\n                return {'score': 65.0, 'level': 'Moderado', 'details': 'Sem dados de tempo'}\n            \n            completed_df = df[\n                (df['Status Categoria'] == 'Done') &\n                (df['Dias para Resolução'].notna()) &\n                (df['Dias para Resolução'] > 0)\n            ].copy()\n            \n            if len(completed_df) < 3:\n                return {'score': 50.0, 'level': 'Baixo', 'details': 'Poucos itens completos'}\n            \n            cycle_times = completed_df['Dias para Resolução']\n            \n            mean_cycle_time = cycle_times.mean()\n            median_cycle_time = cycle_times.median()\n            std_cycle_time = cycle_times.std()\n            \n            # Detectar outliers (tempos muito longos)\n            q75 = cycle_times.quantile(0.75)\n            q25 = cycle_times.quantile(0.25)\n            iqr = q75 - q25\n            upper_bound = q75 + 1.5 * iqr\n            \n            outliers = cycle_times[cycle_times > upper_bound]\n            outlier_ratio = len(outliers) / len(cycle_times)\n            \n            # Score baseado na saúde dos tempos\n            score = 80  # Score base\n            \n            # Penalizar outliers excessivos\n            if outlier_ratio > 0.3:  # >30% outliers\n                score -= 30\n                health_issue = \"Muitos itens com tempo excessivo\"\n            elif outlier_ratio > 0.2:  # >20% outliers\n                score -= 20\n                health_issue = \"Alguns itens com tempo elevado\"\n            elif outlier_ratio > 0.1:  # >10% outliers\n                score -= 10\n                health_issue = \"Poucos itens com tempo elevado\"\n            else:\n                health_issue = \"Tempos consistentes\"\n            \n            # Penalizar variabilidade excessiva\n            if std_cycle_time > mean_cycle_time:  # Desvio > média\n                score -= 15\n                health_issue += \", alta variabilidade\"\n            \n            # Penalizar tempos médios muito altos\n            if mean_cycle_time > 10:  # >10 dias em média\n                score -= 20\n                health_issue += \", tempos muito longos\"\n            elif mean_cycle_time > 7:  # >7 dias\n                score -= 10\n                health_issue += \", tempos longos\"\n            \n            score = max(20, score)  # Mínimo de 20\n            \n            if score >= 80:\n                level = 'Excelente'\n            elif score >= 65:\n                level = 'Bom'\n            elif score >= 50:\n                level = 'Moderado'\n            elif score >= 35:\n                level = 'Baixo'\n            else:\n                level = 'Crítico'\n            \n            return {\n                'score': score,\n                'level': level,\n                'details': health_issue,\n                'mean_cycle_time': round(mean_cycle_time, 1),\n                'median_cycle_time': round(median_cycle_time, 1),\n                'std_cycle_time': round(std_cycle_time, 1),\n                'outlier_ratio': round(outlier_ratio, 2),\n                'outliers_count': len(outliers)\n            }\n            \n        except Exception:\n            return {'score': 60.0, 'level': 'Moderado', 'details': 'Erro na análise'}\n    \n    def _analyze_change_overhead(self, df: pd.DataFrame, \n                                sprint_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Analisa overhead causado por mudanças.\"\"\"\n        try:\n            # Analisar mudanças de status, prioridade, etc.\n            changes_detected = 0\n            total_changes = 0\n            \n            # Contar mudanças de prioridade (se disponível)\n            if 'Prioridade' in df.columns:\n                priority_changes = df['Prioridade'].value_counts()\n                if len(priority_changes) > 1:\n                    total_changes += len(df)\n            \n            # Contar mudanças de responsável\n            if 'Responsável' in df.columns:\n                # Assumir que itens com múltiplos responsáveis tiveram mudança\n                multiple_assignees = df[df['Responsável'].str.contains(',|;', na=False)]\n                changes_detected += len(multiple_assignees)\n                total_changes += len(df)\n            \n            # Analisar itens adicionados durante a sprint\n            sprint_start = sprint_data.get('start_date')\n            if sprint_start and 'Data Criação' in df.columns:\n                if isinstance(sprint_start, str):\n                    sprint_start = datetime.fromisoformat(sprint_start)\n                \n                df_temp = df.copy()\n                df_temp['Data Criação'] = pd.to_datetime(df_temp['Data Criação'], errors='coerce')\n                \n                items_added_during = len(df_temp[df_temp['Data Criação'] > sprint_start])\n                changes_detected += items_added_during\n                total_changes += len(df)\n            \n            if total_changes == 0:\n                change_ratio = 0\n            else:\n                change_ratio = changes_detected / total_changes\n            \n            # Score baseado na quantidade de mudanças\n            if change_ratio <= 0.1:  # <=10% mudanças\n                score = 90\n                level = 'Baixo'\n            elif change_ratio <= 0.2:  # <=20% mudanças\n                score = 75\n                level = 'Moderado'\n            elif change_ratio <= 0.3:  # <=30% mudanças\n                score = 60\n                level = 'Alto'\n            else:  # >30% mudanças\n                score = 40\n                level = 'Crítico'\n            \n            return {\n                'score': score,\n                'level': level,\n                'details': f'{change_ratio:.1%} de itens com mudanças',\n                'change_ratio': change_ratio,\n                'changes_detected': changes_detected,\n                'total_items': total_changes\n            }\n            \n        except Exception:\n            return {'score': 70.0, 'level': 'Moderado', 'details': 'Erro na análise'}\n    \n    def _analyze_rework_frequency(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa frequência de retrabalho.\"\"\"\n        try:\n            # Detectar retrabalho através de padrões\n            rework_indicators = 0\n            total_items = len(df)\n            \n            if total_items == 0:\n                return {'score': 70.0, 'level': 'Moderado', 'details': 'Sem itens'}\n            \n            # 1. Bugs relacionados a features\n            if 'Tipo' in df.columns:\n                bug_keywords = ['bug', 'defeito', 'erro', 'falha', 'correção']\n                df_lower = df['Tipo'].str.lower()\n                bugs = df_lower.str.contains('|'.join(bug_keywords), na=False).sum()\n                rework_indicators += bugs\n            \n            # 2. Itens que voltaram para status anterior\n            if 'Status' in df.columns:\n                # Assumir que itens em \"To Do\" ou \"In Progress\" após terem sido \"Done\" são retrabalho\n                # (não podemos detectar isso facilmente com dados estáticos)\n                pass\n            \n            # 3. Itens com múltiplas revisões (se tivermos campo de comentários)\n            if 'Comentários' in df.columns:\n                items_with_comments = df[df['Comentários'].notna()]\n                # Assumir que itens com muitos comentários podem indicar retrabalho\n                rework_indicators += len(items_with_comments) * 0.3  # Peso menor\n            \n            rework_ratio = rework_indicators / total_items\n            \n            # Score baseado na frequência de retrabalho\n            if rework_ratio <= 0.05:  # <=5% retrabalho\n                score = 95\n                level = 'Baixo'\n            elif rework_ratio <= 0.1:  # <=10% retrabalho\n                score = 80\n                level = 'Moderado'\n            elif rework_ratio <= 0.2:  # <=20% retrabalho\n                score = 60\n                level = 'Alto'\n            else:  # >20% retrabalho\n                score = 40\n                level = 'Crítico'\n            \n            return {\n                'score': score,\n                'level': level,\n                'details': f'{rework_ratio:.1%} de indicadores de retrabalho',\n                'rework_ratio': rework_ratio,\n                'rework_indicators': int(rework_indicators),\n                'total_items': total_items\n            }\n            \n        except Exception:\n            return {'score': 75.0, 'level': 'Moderado', 'details': 'Erro na análise'}\n    \n    def _classify_happiness(self, index: float) -> str:\n        \"\"\"Classifica o índice de felicidade.\"\"\"\n        if index >= 85:\n            return \"Muito Feliz 😊\"\n        elif index >= 70:\n            return \"Feliz 🙂\"\n        elif index >= 55:\n            return \"Neutro 😐\"\n        elif index >= 40:\n            return \"Insatisfeita 😕\"\n        else:\n            return \"Infeliz 😟\"\n    \n    def _identify_stress_factors(self, delivery_consistency: Dict, workload_balance: Dict,\n                                cycle_time_health: Dict, change_overhead: Dict,\n                                rework_frequency: Dict) -> List[Dict[str, Any]]:\n        \"\"\"Identifica fatores de estresse da equipe.\"\"\"\n        stress_factors = []\n        \n        # Analisar cada fator\n        factors = {\n            'Consistência de Entrega': delivery_consistency,\n            'Balanceamento de Carga': workload_balance,\n            'Saúde dos Tempos': cycle_time_health,\n            'Overhead de Mudanças': change_overhead,\n            'Frequência de Retrabalho': rework_frequency\n        }\n        \n        for factor_name, factor_data in factors.items():\n            score = factor_data.get('score', 70)\n            level = factor_data.get('level', 'Moderado')\n            details = factor_data.get('details', '')\n            \n            if score < 50:\n                stress_factors.append({\n                    'factor': factor_name,\n                    'severity': 'Alto',\n                    'score': score,\n                    'description': details,\n                    'impact': 'Pode causar frustração e desmotivação'\n                })\n            elif score < 65:\n                stress_factors.append({\n                    'factor': factor_name,\n                    'severity': 'Médio',\n                    'score': score,\n                    'description': details,\n                    'impact': 'Pode afetar a satisfação da equipe'\n                })\n        \n        return stress_factors\n    \n    def _generate_wellness_recommendations(self, stress_factors: List[Dict]) -> List[str]:\n        \"\"\"Gera recomendações para melhorar bem-estar da equipe.\"\"\"\n        recommendations = []\n        \n        # Recomendações baseadas nos fatores de estresse\n        stress_types = [factor['factor'] for factor in stress_factors \n                       if factor['severity'] in ['Alto', 'Médio']]\n        \n        if 'Balanceamento de Carga' in stress_types:\n            recommendations.extend([\n                \"⚖️ Redistribuir tarefas para equilibrar carga de trabalho\",\n                \"🤝 Implementar pair programming para compartilhar conhecimento\"\n            ])\n        \n        if 'Saúde dos Tempos' in stress_types:\n            recommendations.extend([\n                \"⏰ Revisar estimativas e quebrar tarefas grandes\",\n                \"🚧 Identificar e remover impedimentos que causam atrasos\"\n            ])\n        \n        if 'Overhead de Mudanças' in stress_types:\n            recommendations.extend([\n                \"📋 Melhorar refinamento para reduzir mudanças\",\n                \"🛡️ Proteger a equipe de mudanças de escopo frequentes\"\n            ])\n        \n        if 'Frequência de Retrabalho' in stress_types:\n            recommendations.extend([\n                \"✅ Investir em testes automatizados e code review\",\n                \"📚 Melhorar documentação e critérios de aceitação\"\n            ])\n        \n        if 'Consistência de Entrega' in stress_types:\n            recommendations.extend([\n                \"📊 Implementar daily standups mais efetivos\",\n                \"🎯 Focar em entregar valor incrementalmente\"\n            ])\n        \n        # Recomendações gerais de bem-estar\n        if len(stress_factors) > 2:\n            recommendations.extend([\n                \"🌱 Considerar retrospectivas focadas em bem-estar\",\n                \"💬 Criar espaços seguros para feedback da equipe\",\n                \"🎉 Celebrar pequenas vitórias e reconhecer contribuições\"\n            ])\n        \n        return recommendations[:6]  # Limitar a 6 recomendações\n    \n    def _generate_team_insights(self, delivery_consistency: Dict, workload_balance: Dict,\n                               cycle_time_health: Dict) -> List[str]:\n        \"\"\"Gera insights sobre a equipe.\"\"\"\n        insights = []\n        \n        # Insights positivos\n        if delivery_consistency.get('score', 0) >= 80:\n            insights.append(\"🚀 Equipe demonstra boa consistência nas entregas\")\n        \n        if workload_balance.get('score', 0) >= 80:\n            insights.append(\"⚖️ Carga de trabalho bem distribuída entre membros\")\n        \n        if cycle_time_health.get('score', 0) >= 80:\n            insights.append(\"⏱️ Tempos de ciclo saudáveis indicam bom fluxo de trabalho\")\n        \n        # Insights de alerta\n        if delivery_consistency.get('score', 0) < 50:\n            insights.append(\"⚠️ Padrão de entregas pode indicar dificuldades no planejamento\")\n        \n        if workload_balance.get('score', 0) < 50:\n            insights.append(\"⚠️ Desbalanceamento pode causar sobrecarga em alguns membros\")\n        \n        return insights\n    \n    def _assess_burnout_risk(self, workload_balance: Dict, cycle_time_health: Dict,\n                            change_overhead: Dict) -> str:\n        \"\"\"Avalia risco de burnout da equipe.\"\"\"\n        risk_score = 0\n        \n        # Fatores que aumentam risco de burnout\n        if workload_balance.get('score', 70) < 50:\n            risk_score += 3  # Desbalanceamento severo\n        elif workload_balance.get('score', 70) < 65:\n            risk_score += 1  # Desbalanceamento moderado\n        \n        if cycle_time_health.get('score', 70) < 40:\n            risk_score += 3  # Tempos muito ruins\n        elif cycle_time_health.get('score', 70) < 60:\n            risk_score += 2  # Tempos ruins\n        \n        if change_overhead.get('score', 70) < 50:\n            risk_score += 2  # Muitas mudanças\n        elif change_overhead.get('score', 70) < 70:\n            risk_score += 1  # Mudanças moderadas\n        \n        # Classificar risco\n        if risk_score >= 6:\n            return \"Alto\"\n        elif risk_score >= 3:\n            return \"Médio\"\n        else:\n            return \"Baixo\"\n    \n    def _get_default_result(self) -> Dict[str, Any]:\n        \"\"\"Retorna resultado padrão quando não há dados suficientes.\"\"\"\n        return {\n            'happiness_index': 60.0,\n            'happiness_level': \"Neutro 😐\",\n            'factors': {\n                'delivery_consistency': {'score': 60, 'level': 'Moderada'},\n                'workload_balance': {'score': 60, 'level': 'Moderado'},\n                'cycle_time_health': {'score': 60, 'level': 'Moderado'},\n                'change_overhead': {'score': 60, 'level': 'Moderado'},\n                'rework_frequency': {'score': 60, 'level': 'Moderado'}\n            },\n            'stress_factors': [],\n            'wellness_recommendations': [\"Coletar mais dados para análise precisa\"],\n            'team_insights': [\"Dados insuficientes para insights detalhados\"],\n            'burnout_risk': \"Indeterminado\"\n        }\n    \n    def create_happiness_radar(self, happiness_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gráfico radar do índice de felicidade.\"\"\"\n        try:\n            factors = happiness_data['factors']\n            \n            categories = [\n                'Consistência<br>de Entrega',\n                'Balanceamento<br>de Carga', \n                'Saúde dos<br>Tempos',\n                'Overhead de<br>Mudanças',\n                'Frequência de<br>Retrabalho'\n            ]\n            \n            values = [\n                factors['delivery_consistency']['score'],\n                factors['workload_balance']['score'],\n                factors['cycle_time_health']['score'],\n                factors['change_overhead']['score'],\n                factors['rework_frequency']['score']\n            ]\n            \n            # Fechar o radar\n            values.append(values[0])\n            categories.append(categories[0])\n            \n            # Cores baseadas no índice geral\n            happiness_index = happiness_data['happiness_index']\n            if happiness_index >= 70:\n                color = 'rgba(40, 167, 69, 0.3)'  # Verde\n                line_color = 'rgba(40, 167, 69, 1)'\n            elif happiness_index >= 55:\n                color = 'rgba(255, 193, 7, 0.3)'   # Amarelo\n                line_color = 'rgba(255, 193, 7, 1)'\n            else:\n                color = 'rgba(220, 53, 69, 0.3)'   # Vermelho\n                line_color = 'rgba(220, 53, 69, 1)'\n            \n            fig = go.Figure()\n            \n            fig.add_trace(go.Scatterpolar(\n                r=values,\n                theta=categories,\n                fill='toself',\n                name='Felicidade',\n                fillcolor=color,\n                line_color=line_color,\n                line_width=3\n            ))\n            \n            fig.update_layout(\n                polar=dict(\n                    radialaxis=dict(\n                        visible=True,\n                        range=[0, 100]\n                    )\n                ),\n                title=f\"Radar de Felicidade da Equipe - {happiness_data['happiness_index']:.1f} ({happiness_data['happiness_level']})\",\n                showlegend=False\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gráfico de felicidade: {e}\")\n            return go.Figure()\n    \n    def create_stress_factors_chart(self, happiness_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gráfico de fatores de estresse.\"\"\"\n        try:\n            stress_factors = happiness_data['stress_factors']\n            \n            if not stress_factors:\n                # Criar gráfico vazio com mensagem positiva\n                fig = go.Figure()\n                fig.add_annotation(\n                    text=\"🎉 Nenhum fator de estresse<br>significativo identificado!\",\n                    xref=\"paper\", yref=\"paper\",\n                    x=0.5, y=0.5, xanchor='center', yanchor='middle',\n                    showarrow=False,\n                    font=dict(size=16, color=\"green\")\n                )\n                fig.update_layout(\n                    title=\"Fatores de Estresse da Equipe\",\n                    xaxis=dict(visible=False),\n                    yaxis=dict(visible=False)\n                )\n                return fig\n            \n            factors = [factor['factor'] for factor in stress_factors]\n            scores = [factor['score'] for factor in stress_factors]\n            severities = [factor['severity'] for factor in stress_factors]\n            \n            # Cores baseadas na severidade\n            colors = []\n            for severity in severities:\n                if severity == 'Alto':\n                    colors.append('#dc3545')\n                elif severity == 'Médio':\n                    colors.append('#fd7e14')\n                else:\n                    colors.append('#ffc107')\n            \n            fig = go.Figure()\n            \n            fig.add_trace(go.Bar(\n                x=factors,\n                y=scores,\n                marker_color=colors,\n                text=[f'{s:.0f}' for s in scores],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Score: %{y}<br>Severidade: %{customdata}<extra></extra>',\n                customdata=severities\n            ))\n            \n            fig.update_layout(\n                title=\"Fatores de Estresse Identificados\",\n                xaxis_title=\"Fatores\",\n                yaxis_title=\"Score (menor = maior estresse)\",\n                yaxis=dict(range=[0, 100]),\n                showlegend=False\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gráfico de estresse: {e}\")\n            return go.Figure()"