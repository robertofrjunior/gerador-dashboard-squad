"""
Indicador de Tendência de Qualidade - Análise preditiva da evolução da qualidade.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

from ..utils.log import info, warn, error


class QualityTrendIndicator:
    """
    Analisa tendências de qualidade através de:
    - Evolução da taxa de bugs
    - Padrão de tempo de resolução
    - Complexidade das tarefas
    - Debt técnico inferido
    - Regressões e reincidências
    """
    
    def __init__(self):
        """Inicializa o indicador de tendência de qualidade."""
        self.quality_weights = {
            'bug_trend': 0.30,          # 30% - Tendência de bugs
            'resolution_trend': 0.25,   # 25% - Tendência de resolução
            'complexity_trend': 0.20,   # 20% - Tendência de complexidade
            'technical_debt': 0.15,     # 15% - Dívida técnica
            'regression_rate': 0.10     # 10% - Taxa de regressão
        }
    
    def calculate_quality_trend(self, df: pd.DataFrame, 
                               historical_data: Optional[List[pd.DataFrame]] = None) -> Dict[str, Any]:
        """
        Calcula análise de tendência de qualidade.
        
        Args:
            df: DataFrame com dados da sprint atual
            historical_data: Lista de DataFrames de sprints anteriores
            
        Returns:
            Dicionário com análise completa de tendência
        """
        try:
            info(\"Calculando tendência de qualidade...\")\n            \n            if df.empty:\n                return self._get_default_result()\n            \n            # 1. Análise de tendência de bugs\n            bug_trend = self._analyze_bug_trend(df, historical_data)\n            \n            # 2. Análise de tendência de resolução\n            resolution_trend = self._analyze_resolution_trend(df, historical_data)\n            \n            # 3. Análise de tendência de complexidade\n            complexity_trend = self._analyze_complexity_trend(df, historical_data)\n            \n            # 4. Análise de dívida técnica\n            technical_debt = self._analyze_technical_debt(df)\n            \n            # 5. Análise de taxa de regressão\n            regression_rate = self._analyze_regression_rate(df, historical_data)\n            \n            # Calcular score geral de tendência\n            trend_score = (\n                bug_trend['score'] * self.quality_weights['bug_trend'] +\n                resolution_trend['score'] * self.quality_weights['resolution_trend'] +\n                complexity_trend['score'] * self.quality_weights['complexity_trend'] +\n                technical_debt['score'] * self.quality_weights['technical_debt'] +\n                regression_rate['score'] * self.quality_weights['regression_rate']\n            )\n            \n            # Classificar tendência\n            trend_direction = self._classify_trend(trend_score)\n            \n            # Previsão para próximas sprints\n            quality_forecast = self._generate_quality_forecast(\n                bug_trend, resolution_trend, complexity_trend\n            )\n            \n            # Alertas de qualidade\n            quality_alerts = self._generate_quality_alerts(\n                bug_trend, resolution_trend, technical_debt\n            )\n            \n            # Recomendações preventivas\n            preventive_actions = self._generate_preventive_actions(\n                bug_trend, technical_debt, complexity_trend\n            )\n            \n            result = {\n                'trend_score': round(trend_score, 1),\n                'trend_direction': trend_direction,\n                'components': {\n                    'bug_trend': bug_trend,\n                    'resolution_trend': resolution_trend,\n                    'complexity_trend': complexity_trend,\n                    'technical_debt': technical_debt,\n                    'regression_rate': regression_rate\n                },\n                'quality_forecast': quality_forecast,\n                'quality_alerts': quality_alerts,\n                'preventive_actions': preventive_actions,\n                'health_indicators': self._calculate_health_indicators(\n                    bug_trend, resolution_trend, technical_debt\n                ),\n                'risk_assessment': self._assess_quality_risk(\n                    trend_score, quality_alerts\n                )\n            }\n            \n            info(f\"Tendência de qualidade: {trend_score:.1f} ({trend_direction})\")\n            return result\n            \n        except Exception as e:\n            error(f\"Erro ao calcular tendência de qualidade: {e}\")\n            return self._get_default_result()\n    \n    def _analyze_bug_trend(self, df: pd.DataFrame, \n                          historical_data: Optional[List[pd.DataFrame]]) -> Dict[str, Any]:\n        \"\"\"Analisa tendência na taxa de bugs.\"\"\"\n        try:\n            # Identificar bugs na sprint atual\n            current_bugs = self._identify_bugs(df)\n            current_total = len(df)\n            current_bug_rate = current_bugs / current_total if current_total > 0 else 0\n            \n            trend_data = {'current': current_bug_rate}\n            \n            # Analisar histórico se disponível\n            if historical_data:\n                historical_rates = []\n                for hist_df in historical_data[-5:]:  # Últimas 5 sprints\n                    if not hist_df.empty:\n                        hist_bugs = self._identify_bugs(hist_df)\n                        hist_total = len(hist_df)\n                        hist_rate = hist_bugs / hist_total if hist_total > 0 else 0\n                        historical_rates.append(hist_rate)\n                \n                if historical_rates:\n                    trend_data['historical'] = historical_rates\n                    trend_data['average_historical'] = np.mean(historical_rates)\n                    \n                    # Calcular tendência (regressão linear simples)\n                    if len(historical_rates) >= 3:\n                        x = np.arange(len(historical_rates))\n                        slope, _ = np.polyfit(x, historical_rates, 1)\n                        trend_data['slope'] = slope\n            \n            # Calcular score baseado na tendência\n            score = self._calculate_bug_trend_score(trend_data)\n            \n            return {\n                'score': score,\n                'current_bug_rate': round(current_bug_rate, 3),\n                'bugs_count': current_bugs,\n                'total_items': current_total,\n                'trend_data': trend_data,\n                'interpretation': self._interpret_bug_trend(trend_data, score)\n            }\n            \n        except Exception:\n            return {\n                'score': 70.0,\n                'current_bug_rate': 0.0,\n                'bugs_count': 0,\n                'total_items': 0,\n                'trend_data': {},\n                'interpretation': 'Dados insuficientes'\n            }\n    \n    def _analyze_resolution_trend(self, df: pd.DataFrame,\n                                 historical_data: Optional[List[pd.DataFrame]]) -> Dict[str, Any]:\n        \"\"\"Analisa tendência no tempo de resolução.\"\"\"\n        try:\n            # Tempo de resolução atual\n            if 'Dias para Resolução' not in df.columns:\n                return self._get_default_resolution_trend()\n            \n            completed_df = df[\n                (df['Status Categoria'] == 'Done') &\n                (df['Dias para Resolução'].notna()) &\n                (df['Dias para Resolução'] > 0)\n            ]\n            \n            if len(completed_df) == 0:\n                return self._get_default_resolution_trend()\n            \n            current_avg_time = completed_df['Dias para Resolução'].mean()\n            current_median_time = completed_df['Dias para Resolução'].median()\n            \n            trend_data = {\n                'current_avg': current_avg_time,\n                'current_median': current_median_time\n            }\n            \n            # Analisar histórico\n            if historical_data:\n                historical_times = []\n                for hist_df in historical_data[-5:]:\n                    if not hist_df.empty and 'Dias para Resolução' in hist_df.columns:\n                        hist_completed = hist_df[\n                            (hist_df['Status Categoria'] == 'Done') &\n                            (hist_df['Dias para Resolução'].notna()) &\n                            (hist_df['Dias para Resolução'] > 0)\n                        ]\n                        if len(hist_completed) > 0:\n                            historical_times.append(hist_completed['Dias para Resolução'].mean())\n                \n                if historical_times:\n                    trend_data['historical'] = historical_times\n                    trend_data['average_historical'] = np.mean(historical_times)\n                    \n                    # Calcular tendência\n                    if len(historical_times) >= 3:\n                        x = np.arange(len(historical_times))\n                        slope, _ = np.polyfit(x, historical_times, 1)\n                        trend_data['slope'] = slope\n            \n            # Calcular score\n            score = self._calculate_resolution_trend_score(trend_data)\n            \n            return {\n                'score': score,\n                'current_avg_time': round(current_avg_time, 1),\n                'current_median_time': round(current_median_time, 1),\n                'completed_items': len(completed_df),\n                'trend_data': trend_data,\n                'interpretation': self._interpret_resolution_trend(trend_data, score)\n            }\n            \n        except Exception:\n            return self._get_default_resolution_trend()\n    \n    def _analyze_complexity_trend(self, df: pd.DataFrame,\n                                 historical_data: Optional[List[pd.DataFrame]]) -> Dict[str, Any]:\n        \"\"\"Analisa tendência na complexidade das tarefas.\"\"\"\n        try:\n            # Analisar complexidade através de story points e tipos\n            complexity_indicators = {\n                'avg_story_points': 0,\n                'large_tasks_ratio': 0,\n                'task_diversity': 0\n            }\n            \n            # Story points médio\n            if 'Story Points' in df.columns:\n                sp_data = df[df['Story Points'].notna() & (df['Story Points'] > 0)]\n                if len(sp_data) > 0:\n                    complexity_indicators['avg_story_points'] = sp_data['Story Points'].mean()\n                    \n                    # Taxa de tarefas grandes (>8 story points)\n                    large_tasks = len(sp_data[sp_data['Story Points'] > 8])\n                    complexity_indicators['large_tasks_ratio'] = large_tasks / len(sp_data)\n            \n            # Diversidade de tipos de tarefa\n            if 'Tipo' in df.columns:\n                unique_types = df['Tipo'].nunique()\n                total_items = len(df)\n                complexity_indicators['task_diversity'] = unique_types / total_items if total_items > 0 else 0\n            \n            # Comparar com histórico\n            trend_data = {'current': complexity_indicators}\n            \n            if historical_data:\n                historical_complexity = []\n                for hist_df in historical_data[-5:]:\n                    if not hist_df.empty:\n                        hist_indicators = self._extract_complexity_indicators(hist_df)\n                        historical_complexity.append(hist_indicators)\n                \n                if historical_complexity:\n                    trend_data['historical'] = historical_complexity\n            \n            # Calcular score\n            score = self._calculate_complexity_trend_score(trend_data)\n            \n            return {\n                'score': score,\n                'complexity_indicators': complexity_indicators,\n                'trend_data': trend_data,\n                'interpretation': self._interpret_complexity_trend(trend_data, score)\n            }\n            \n        except Exception:\n            return {\n                'score': 70.0,\n                'complexity_indicators': {},\n                'trend_data': {},\n                'interpretation': 'Dados insuficientes'\n            }\n    \n    def _analyze_technical_debt(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa indicadores de dívida técnica.\"\"\"\n        try:\n            debt_indicators = {\n                'technical_tasks_ratio': 0,\n                'maintenance_ratio': 0,\n                'refactoring_ratio': 0,\n                'urgent_fixes_ratio': 0\n            }\n            \n            total_items = len(df)\n            \n            if total_items == 0:\n                return self._get_default_technical_debt()\n            \n            # Identificar tarefas técnicas\n            if 'Tipo' in df.columns or 'Título' in df.columns:\n                technical_keywords = [\n                    'refactor', 'refatoração', 'técnica', 'infraestrutura',\n                    'manutenção', 'performance', 'otimização', 'limpeza'\n                ]\n                \n                maintenance_keywords = [\n                    'manutenção', 'atualização', 'upgrade', 'correção',\n                    'ajuste', 'melhoria'\n                ]\n                \n                urgent_keywords = [\n                    'urgente', 'crítico', 'hotfix', 'emergência'\n                ]\n                \n                # Combinar texto de tipo e título para análise\n                text_columns = []\n                if 'Tipo' in df.columns:\n                    text_columns.append(df['Tipo'].fillna(''))\n                if 'Título' in df.columns:\n                    text_columns.append(df['Título'].fillna(''))\n                \n                if text_columns:\n                    combined_text = ' '.join([col.str.lower() for col in text_columns])\n                    \n                    # Contar ocorrências\n                    technical_count = sum(\n                        combined_text.str.contains(keyword, na=False).sum()\n                        for keyword in technical_keywords\n                    )\n                    \n                    maintenance_count = sum(\n                        combined_text.str.contains(keyword, na=False).sum()\n                        for keyword in maintenance_keywords\n                    )\n                    \n                    urgent_count = sum(\n                        combined_text.str.contains(keyword, na=False).sum()\n                        for keyword in urgent_keywords\n                    )\n                    \n                    debt_indicators['technical_tasks_ratio'] = min(1.0, technical_count / total_items)\n                    debt_indicators['maintenance_ratio'] = min(1.0, maintenance_count / total_items)\n                    debt_indicators['urgent_fixes_ratio'] = min(1.0, urgent_count / total_items)\n            \n            # Calcular score de dívida técnica (inverso - menos dívida = melhor score)\n            score = self._calculate_technical_debt_score(debt_indicators)\n            \n            return {\n                'score': score,\n                'debt_indicators': debt_indicators,\n                'interpretation': self._interpret_technical_debt(debt_indicators, score),\n                'debt_level': self._classify_debt_level(score)\n            }\n            \n        except Exception:\n            return self._get_default_technical_debt()\n    \n    def _analyze_regression_rate(self, df: pd.DataFrame,\n                                historical_data: Optional[List[pd.DataFrame]]) -> Dict[str, Any]:\n        \"\"\"Analisa taxa de regressão e reincidência.\"\"\"\n        try:\n            # Identificar possíveis regressões\n            regression_indicators = 0\n            total_items = len(df)\n            \n            if total_items == 0:\n                return {'score': 80.0, 'regression_rate': 0, 'interpretation': 'Sem itens'}\n            \n            # Buscar por padrões de regressão\n            if 'Título' in df.columns:\n                regression_keywords = [\n                    'regressão', 'voltou', 'novamente', 'denovo', 'again',\n                    'reincidência', 'reapareceu'\n                ]\n                \n                titles_lower = df['Título'].str.lower().fillna('')\n                regression_indicators = sum(\n                    titles_lower.str.contains(keyword, na=False).sum()\n                    for keyword in regression_keywords\n                )\n            \n            # Identificar bugs relacionados a funcionalidades já implementadas\n            if 'Tipo' in df.columns:\n                bug_types = ['bug', 'defeito', 'erro']\n                df_lower = df['Tipo'].str.lower().fillna('')\n                bugs_count = sum(\n                    df_lower.str.contains(bug_type, na=False).sum()\n                    for bug_type in bug_types\n                )\n                \n                # Assumir que parte dos bugs são regressões\n                regression_indicators += bugs_count * 0.3  # 30% dos bugs podem ser regressões\n            \n            regression_rate = min(1.0, regression_indicators / total_items)\n            \n            # Calcular score (inverso - menos regressão = melhor)\n            if regression_rate <= 0.05:  # ≤5%\n                score = 95\n            elif regression_rate <= 0.1:  # ≤10%\n                score = 85\n            elif regression_rate <= 0.15:  # ≤15%\n                score = 70\n            elif regression_rate <= 0.25:  # ≤25%\n                score = 50\n            else:\n                score = 30\n            \n            return {\n                'score': score,\n                'regression_rate': round(regression_rate, 3),\n                'regression_indicators': int(regression_indicators),\n                'total_items': total_items,\n                'interpretation': self._interpret_regression_rate(regression_rate, score)\n            }\n            \n        except Exception:\n            return {\n                'score': 80.0,\n                'regression_rate': 0,\n                'regression_indicators': 0,\n                'total_items': 0,\n                'interpretation': 'Dados insuficientes'\n            }\n    \n    def _identify_bugs(self, df: pd.DataFrame) -> int:\n        \"\"\"Identifica número de bugs no DataFrame.\"\"\"\n        bugs_count = 0\n        \n        if 'Tipo' in df.columns:\n            bug_keywords = ['bug', 'defeito', 'erro', 'falha']\n            df_lower = df['Tipo'].str.lower().fillna('')\n            bugs_count = sum(\n                df_lower.str.contains(keyword, na=False).sum()\n                for keyword in bug_keywords\n            )\n        \n        return bugs_count\n    \n    def _extract_complexity_indicators(self, df: pd.DataFrame) -> Dict[str, float]:\n        \"\"\"Extrai indicadores de complexidade de um DataFrame.\"\"\"\n        indicators = {\n            'avg_story_points': 0,\n            'large_tasks_ratio': 0,\n            'task_diversity': 0\n        }\n        \n        if 'Story Points' in df.columns:\n            sp_data = df[df['Story Points'].notna() & (df['Story Points'] > 0)]\n            if len(sp_data) > 0:\n                indicators['avg_story_points'] = sp_data['Story Points'].mean()\n                large_tasks = len(sp_data[sp_data['Story Points'] > 8])\n                indicators['large_tasks_ratio'] = large_tasks / len(sp_data)\n        \n        if 'Tipo' in df.columns:\n            unique_types = df['Tipo'].nunique()\n            total_items = len(df)\n            indicators['task_diversity'] = unique_types / total_items if total_items > 0 else 0\n        \n        return indicators\n    \n    def _calculate_bug_trend_score(self, trend_data: Dict) -> float:\n        \"\"\"Calcula score baseado na tendência de bugs.\"\"\"\n        current_rate = trend_data.get('current', 0)\n        \n        # Score base baseado na taxa atual\n        if current_rate <= 0.05:  # ≤5%\n            base_score = 90\n        elif current_rate <= 0.1:  # ≤10%\n            base_score = 75\n        elif current_rate <= 0.2:  # ≤20%\n            base_score = 60\n        else:\n            base_score = 40\n        \n        # Ajustar baseado na tendência\n        if 'slope' in trend_data:\n            slope = trend_data['slope']\n            if slope < -0.02:  # Tendência de melhoria\n                base_score += 10\n            elif slope > 0.02:  # Tendência de piora\n                base_score -= 15\n        \n        return max(10, min(100, base_score))\n    \n    def _calculate_resolution_trend_score(self, trend_data: Dict) -> float:\n        \"\"\"Calcula score baseado na tendência de resolução.\"\"\"\n        current_avg = trend_data.get('current_avg', 5)\n        \n        # Score base baseado no tempo atual\n        if current_avg <= 3:  # ≤3 dias\n            base_score = 90\n        elif current_avg <= 5:  # ≤5 dias\n            base_score = 80\n        elif current_avg <= 8:  # ≤8 dias\n            base_score = 65\n        elif current_avg <= 12:  # ≤12 dias\n            base_score = 50\n        else:\n            base_score = 30\n        \n        # Ajustar baseado na tendência\n        if 'slope' in trend_data:\n            slope = trend_data['slope']\n            if slope < -0.5:  # Tempos diminuindo\n                base_score += 10\n            elif slope > 1.0:  # Tempos aumentando\n                base_score -= 15\n        \n        return max(10, min(100, base_score))\n    \n    def _calculate_complexity_trend_score(self, trend_data: Dict) -> float:\n        \"\"\"Calcula score baseado na tendência de complexidade.\"\"\"\n        current = trend_data.get('current', {})\n        \n        base_score = 75  # Score neutro\n        \n        # Ajustar baseado nos indicadores atuais\n        avg_sp = current.get('avg_story_points', 5)\n        large_ratio = current.get('large_tasks_ratio', 0)\n        diversity = current.get('task_diversity', 0.3)\n        \n        # Penalizar alta complexidade\n        if avg_sp > 8:\n            base_score -= 15\n        elif avg_sp > 5:\n            base_score -= 5\n        \n        if large_ratio > 0.3:  # >30% tarefas grandes\n            base_score -= 10\n        elif large_ratio > 0.2:  # >20% tarefas grandes\n            base_score -= 5\n        \n        # Premiar diversidade moderada\n        if 0.2 <= diversity <= 0.5:\n            base_score += 5\n        elif diversity > 0.7:  # Muito diverso pode ser complexo\n            base_score -= 5\n        \n        return max(20, min(100, base_score))\n    \n    def _calculate_technical_debt_score(self, debt_indicators: Dict) -> float:\n        \"\"\"Calcula score de dívida técnica (inverso).\"\"\"\n        technical_ratio = debt_indicators.get('technical_tasks_ratio', 0)\n        maintenance_ratio = debt_indicators.get('maintenance_ratio', 0)\n        urgent_ratio = debt_indicators.get('urgent_fixes_ratio', 0)\n        \n        # Score base alto (pouca dívida)\n        base_score = 85\n        \n        # Penalizar alta proporção de tarefas técnicas\n        if technical_ratio > 0.4:  # >40%\n            base_score -= 25\n        elif technical_ratio > 0.3:  # >30%\n            base_score -= 15\n        elif technical_ratio > 0.2:  # >20%\n            base_score -= 10\n        \n        # Penalizar muita manutenção\n        if maintenance_ratio > 0.3:\n            base_score -= 15\n        elif maintenance_ratio > 0.2:\n            base_score -= 10\n        \n        # Penalizar fixes urgentes\n        if urgent_ratio > 0.1:  # >10%\n            base_score -= 20\n        elif urgent_ratio > 0.05:  # >5%\n            base_score -= 10\n        \n        return max(20, min(100, base_score))\n    \n    def _classify_trend(self, score: float) -> str:\n        \"\"\"Classifica a tendência geral de qualidade.\"\"\"\n        if score >= 85:\n            return \"Excelente ⬆️\"\n        elif score >= 75:\n            return \"Melhorando ↗️\"\n        elif score >= 65:\n            return \"Estável ➡️\"\n        elif score >= 50:\n            return \"Preocupante ↘️\"\n        else:\n            return \"Deteriorando ⬇️\"\n    \n    def _generate_quality_forecast(self, bug_trend: Dict, resolution_trend: Dict,\n                                  complexity_trend: Dict) -> Dict[str, Any]:\n        \"\"\"Gera previsão de qualidade para próximas sprints.\"\"\"\n        forecasts = []\n        \n        # Previsão baseada em bugs\n        bug_score = bug_trend['score']\n        if bug_score >= 80:\n            forecasts.append(\"📈 Tendência de baixa incidência de bugs\")\n        elif bug_score < 50:\n            forecasts.append(\"⚠️ Risco de aumento na taxa de bugs\")\n        \n        # Previsão baseada em resolução\n        resolution_score = resolution_trend['score']\n        if resolution_score >= 80:\n            forecasts.append(\"⏱️ Tempos de resolução devem permanecer saudáveis\")\n        elif resolution_score < 50:\n            forecasts.append(\"🐌 Risco de aumento nos tempos de resolução\")\n        \n        # Previsão baseada em complexidade\n        complexity_score = complexity_trend['score']\n        if complexity_score < 60:\n            forecasts.append(\"🔧 Complexidade crescente pode impactar qualidade\")\n        \n        return {\n            'short_term': forecasts[:2],  # Próximas 1-2 sprints\n            'medium_term': forecasts[2:],  # Próximas 3-5 sprints\n            'confidence_level': self._calculate_forecast_confidence(\n                bug_trend, resolution_trend, complexity_trend\n            )\n        }\n    \n    def _generate_quality_alerts(self, bug_trend: Dict, resolution_trend: Dict,\n                                technical_debt: Dict) -> List[Dict[str, Any]]:\n        \"\"\"Gera alertas de qualidade.\"\"\"\n        alerts = []\n        \n        # Alertas de bugs\n        if bug_trend['score'] < 50:\n            alerts.append({\n                'type': 'bug_increase',\n                'severity': 'high',\n                'message': f\"Taxa de bugs em {bug_trend['current_bug_rate']:.1%} - acima do aceitável\",\n                'action': 'Revisar processo de testes e qualidade'\n            })\n        \n        # Alertas de tempo de resolução\n        if resolution_trend['score'] < 50:\n            alerts.append({\n                'type': 'resolution_time',\n                'severity': 'medium',\n                'message': f\"Tempo médio de resolução: {resolution_trend.get('current_avg_time', 0):.1f} dias\",\n                'action': 'Investigar gargalos no processo'\n            })\n        \n        # Alertas de dívida técnica\n        if technical_debt['score'] < 60:\n            alerts.append({\n                'type': 'technical_debt',\n                'severity': 'medium',\n                'message': \"Alta proporção de tarefas técnicas detectada\",\n                'action': 'Planejar redução da dívida técnica'\n            })\n        \n        return alerts\n    \n    def _generate_preventive_actions(self, bug_trend: Dict, technical_debt: Dict,\n                                   complexity_trend: Dict) -> List[str]:\n        \"\"\"Gera ações preventivas para manter qualidade.\"\"\"\n        actions = []\n        \n        if bug_trend['score'] < 70:\n            actions.extend([\n                \"🔍 Implementar code review obrigatório\",\n                \"🧪 Aumentar cobertura de testes automatizados\"\n            ])\n        \n        if technical_debt['score'] < 70:\n            actions.extend([\n                \"🏗️ Alocar tempo para refatoração em cada sprint\",\n                \"📊 Monitorar métricas de qualidade de código\"\n            ])\n        \n        if complexity_trend['score'] < 65:\n            actions.extend([\n                \"✂️ Quebrar histórias grandes em menores\",\n                \"📋 Melhorar critérios de aceitação\"\n            ])\n        \n        # Ações gerais\n        actions.extend([\n            \"📚 Documentar padrões de qualidade da equipe\",\n            \"🎯 Definir métricas de qualidade claras\"\n        ])\n        \n        return actions[:5]  # Limitar a 5 ações\n    \n    def _calculate_health_indicators(self, bug_trend: Dict, resolution_trend: Dict,\n                                   technical_debt: Dict) -> Dict[str, str]:\n        \"\"\"Calcula indicadores de saúde da qualidade.\"\"\"\n        indicators = {}\n        \n        # Saúde de bugs\n        bug_score = bug_trend['score']\n        if bug_score >= 80:\n            indicators['bug_health'] = \"Saudável\"\n        elif bug_score >= 60:\n            indicators['bug_health'] = \"Moderada\"\n        else:\n            indicators['bug_health'] = \"Crítica\"\n        \n        # Saúde de resolução\n        resolution_score = resolution_trend['score']\n        if resolution_score >= 80:\n            indicators['resolution_health'] = \"Saudável\"\n        elif resolution_score >= 60:\n            indicators['resolution_health'] = \"Moderada\"\n        else:\n            indicators['resolution_health'] = \"Crítica\"\n        \n        # Saúde de dívida técnica\n        debt_score = technical_debt['score']\n        if debt_score >= 80:\n            indicators['debt_health'] = \"Saudável\"\n        elif debt_score >= 60:\n            indicators['debt_health'] = \"Moderada\"\n        else:\n            indicators['debt_health'] = \"Crítica\"\n        \n        return indicators\n    \n    def _assess_quality_risk(self, trend_score: float, alerts: List[Dict]) -> str:\n        \"\"\"Avalia risco geral de qualidade.\"\"\"\n        high_severity_alerts = len([a for a in alerts if a.get('severity') == 'high'])\n        medium_severity_alerts = len([a for a in alerts if a.get('severity') == 'medium'])\n        \n        if trend_score < 50 or high_severity_alerts >= 2:\n            return \"Alto\"\n        elif trend_score < 65 or high_severity_alerts >= 1 or medium_severity_alerts >= 2:\n            return \"Médio\"\n        else:\n            return \"Baixo\"\n    \n    def _calculate_forecast_confidence(self, bug_trend: Dict, resolution_trend: Dict,\n                                     complexity_trend: Dict) -> str:\n        \"\"\"Calcula confiança da previsão.\"\"\"\n        # Verificar se temos dados históricos suficientes\n        has_bug_history = 'historical' in bug_trend.get('trend_data', {})\n        has_resolution_history = 'historical' in resolution_trend.get('trend_data', {})\n        \n        if has_bug_history and has_resolution_history:\n            return \"Alta\"\n        elif has_bug_history or has_resolution_history:\n            return \"Média\"\n        else:\n            return \"Baixa\"\n    \n    # Métodos auxiliares para resultados padrão\n    def _get_default_result(self) -> Dict[str, Any]:\n        \"\"\"Retorna resultado padrão.\"\"\"\n        return {\n            'trend_score': 70.0,\n            'trend_direction': \"Estável ➡️\",\n            'components': {\n                'bug_trend': {'score': 70, 'interpretation': 'Dados insuficientes'},\n                'resolution_trend': {'score': 70, 'interpretation': 'Dados insuficientes'},\n                'complexity_trend': {'score': 70, 'interpretation': 'Dados insuficientes'},\n                'technical_debt': {'score': 70, 'interpretation': 'Dados insuficientes'},\n                'regression_rate': {'score': 70, 'interpretation': 'Dados insuficientes'}\n            },\n            'quality_forecast': {'short_term': [], 'medium_term': [], 'confidence_level': 'Baixa'},\n            'quality_alerts': [],\n            'preventive_actions': [\"Coletar mais dados para análise precisa\"],\n            'health_indicators': {'bug_health': 'Indeterminada', 'resolution_health': 'Indeterminada', 'debt_health': 'Indeterminada'},\n            'risk_assessment': 'Indeterminado'\n        }\n    \n    def _get_default_resolution_trend(self) -> Dict[str, Any]:\n        \"\"\"Retorna resultado padrão para tendência de resolução.\"\"\"\n        return {\n            'score': 70.0,\n            'current_avg_time': 0,\n            'current_median_time': 0,\n            'completed_items': 0,\n            'trend_data': {},\n            'interpretation': 'Dados insuficientes'\n        }\n    \n    def _get_default_technical_debt(self) -> Dict[str, Any]:\n        \"\"\"Retorna resultado padrão para dívida técnica.\"\"\"\n        return {\n            'score': 70.0,\n            'debt_indicators': {},\n            'interpretation': 'Dados insuficientes',\n            'debt_level': 'Indeterminado'\n        }\n    \n    # Métodos de interpretação\n    def _interpret_bug_trend(self, trend_data: Dict, score: float) -> str:\n        \"\"\"Interpreta tendência de bugs.\"\"\"\n        current_rate = trend_data.get('current', 0)\n        \n        if score >= 80:\n            return f\"Baixa taxa de bugs ({current_rate:.1%}) - qualidade excelente\"\n        elif score >= 60:\n            return f\"Taxa de bugs moderada ({current_rate:.1%}) - monitorar\"\n        else:\n            return f\"Taxa de bugs alta ({current_rate:.1%}) - requer ação imediata\"\n    \n    def _interpret_resolution_trend(self, trend_data: Dict, score: float) -> str:\n        \"\"\"Interpreta tendência de resolução.\"\"\"\n        current_avg = trend_data.get('current_avg', 0)\n        \n        if score >= 80:\n            return f\"Tempos de resolução saudáveis ({current_avg:.1f} dias)\"\n        elif score >= 60:\n            return f\"Tempos de resolução moderados ({current_avg:.1f} dias)\"\n        else:\n            return f\"Tempos de resolução elevados ({current_avg:.1f} dias)\"\n    \n    def _interpret_complexity_trend(self, trend_data: Dict, score: float) -> str:\n        \"\"\"Interpreta tendência de complexidade.\"\"\"\n        if score >= 75:\n            return \"Complexidade das tarefas sob controle\"\n        elif score >= 60:\n            return \"Complexidade moderada - monitorar\"\n        else:\n            return \"Complexidade elevada - simplificar tarefas\"\n    \n    def _interpret_technical_debt(self, debt_indicators: Dict, score: float) -> str:\n        \"\"\"Interpreta nível de dívida técnica.\"\"\"\n        technical_ratio = debt_indicators.get('technical_tasks_ratio', 0)\n        \n        if score >= 80:\n            return \"Baixa dívida técnica - boa saúde do código\"\n        elif score >= 60:\n            return f\"Dívida técnica moderada ({technical_ratio:.1%} tarefas técnicas)\"\n        else:\n            return f\"Alta dívida técnica ({technical_ratio:.1%} tarefas técnicas) - planejar redução\"\n    \n    def _interpret_regression_rate(self, regression_rate: float, score: float) -> str:\n        \"\"\"Interpreta taxa de regressão.\"\"\"\n        if score >= 80:\n            return f\"Baixa taxa de regressão ({regression_rate:.1%}) - boa estabilidade\"\n        elif score >= 60:\n            return f\"Taxa de regressão moderada ({regression_rate:.1%}) - monitorar\"\n        else:\n            return f\"Alta taxa de regressão ({regression_rate:.1%}) - revisar testes\"\n    \n    def _classify_debt_level(self, score: float) -> str:\n        \"\"\"Classifica nível de dívida técnica.\"\"\"\n        if score >= 80:\n            return \"Baixa\"\n        elif score >= 60:\n            return \"Moderada\"\n        elif score >= 40:\n            return \"Alta\"\n        else:\n            return \"Crítica\"\n    \n    def create_trend_overview_chart(self, quality_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gráfico de overview da tendência de qualidade.\"\"\"\n        try:\n            components = quality_data['components']\n            \n            categories = ['Bugs', 'Resolução', 'Complexidade', 'Dívida Técnica', 'Regressão']\n            scores = [\n                components['bug_trend']['score'],\n                components['resolution_trend']['score'],\n                components['complexity_trend']['score'],\n                components['technical_debt']['score'],\n                components['regression_rate']['score']\n            ]\n            \n            # Cores baseadas nos scores\n            colors = []\n            for score in scores:\n                if score >= 80:\n                    colors.append('#28a745')  # Verde\n                elif score >= 60:\n                    colors.append('#ffc107')  # Amarelo\n                else:\n                    colors.append('#dc3545')  # Vermelho\n            \n            fig = go.Figure()\n            \n            fig.add_trace(go.Bar(\n                x=categories,\n                y=scores,\n                marker_color=colors,\n                text=[f'{s:.0f}' for s in scores],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Score: %{y:.1f}<extra></extra>'\n            ))\n            \n            # Linha de meta (80)\n            fig.add_hline(y=80, line_dash=\"dash\", line_color=\"green\",\n                         annotation_text=\"Meta de Qualidade (80)\")\n            \n            fig.update_layout(\n                title=f\"Tendência de Qualidade - Score Geral: {quality_data['trend_score']:.1f} ({quality_data['trend_direction']})\",\n                xaxis_title=\"Componentes\",\n                yaxis_title=\"Score\",\n                yaxis=dict(range=[0, 100]),\n                showlegend=False\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gráfico de tendência: {e}\")\n            return go.Figure()\n    \n    def create_quality_forecast_chart(self, quality_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gráfico de previsão de qualidade.\"\"\"\n        try:\n            # Simular dados históricos e projeção\n            # Em implementação real, usaria dados históricos reais\n            sprints = ['Sprint -4', 'Sprint -3', 'Sprint -2', 'Sprint -1', 'Sprint Atual', 'Projeção +1', 'Projeção +2']\n            \n            # Simular tendências baseadas nos scores atuais\n            current_score = quality_data['trend_score']\n            \n            # Criar tendência simulada\n            historical_scores = [\n                current_score - 15 + np.random.normal(0, 3),\n                current_score - 10 + np.random.normal(0, 3),\n                current_score - 5 + np.random.normal(0, 3),\n                current_score - 2 + np.random.normal(0, 3),\n                current_score\n            ]\n            \n            # Projeção baseada na tendência\n            if current_score >= 75:\n                projected_scores = [current_score + 2, current_score + 3]\n            elif current_score >= 60:\n                projected_scores = [current_score + 1, current_score + 1]\n            else:\n                projected_scores = [current_score - 1, current_score - 2]\n            \n            all_scores = historical_scores + projected_scores\n            \n            fig = go.Figure()\n            \n            # Linha histórica\n            fig.add_trace(go.Scatter(\n                x=sprints[:5],\n                y=all_scores[:5],\n                mode='lines+markers',\n                name='Histórico',\n                line=dict(color='blue', width=3),\n                marker=dict(size=8)\n            ))\n            \n            # Linha de projeção\n            fig.add_trace(go.Scatter(\n                x=sprints[4:],\n                y=all_scores[4:],\n                mode='lines+markers',\n                name='Projeção',\n                line=dict(color='orange', width=3, dash='dash'),\n                marker=dict(size=8)\n            ))\n            \n            # Zona de meta\n            fig.add_hline(y=80, line_dash=\"dash\", line_color=\"green\",\n                         annotation_text=\"Meta de Qualidade\")\n            \n            fig.update_layout(\n                title=\"Projeção de Tendência de Qualidade\",\n                xaxis_title=\"Sprints\",\n                yaxis_title=\"Score de Qualidade\",\n                yaxis=dict(range=[0, 100]),\n                hovermode='x unified'\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gráfico de projeção: {e}\")\n            return go.Figure()"