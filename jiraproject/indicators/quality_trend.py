"""
Indicador de Tend√™ncia de Qualidade - An√°lise preditiva da evolu√ß√£o da qualidade.
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

from ..utils.log import info, warn, error


class QualityTrendIndicator:
    """
    Analisa tend√™ncias de qualidade atrav√©s de:
    - Evolu√ß√£o da taxa de bugs
    - Padr√£o de tempo de resolu√ß√£o
    - Complexidade das tarefas
    - Debt t√©cnico inferido
    - Regress√µes e reincid√™ncias
    """
    
    def __init__(self):
        """Inicializa o indicador de tend√™ncia de qualidade."""
        self.quality_weights = {
            'bug_trend': 0.30,          # 30% - Tend√™ncia de bugs
            'resolution_trend': 0.25,   # 25% - Tend√™ncia de resolu√ß√£o
            'complexity_trend': 0.20,   # 20% - Tend√™ncia de complexidade
            'technical_debt': 0.15,     # 15% - D√≠vida t√©cnica
            'regression_rate': 0.10     # 10% - Taxa de regress√£o
        }
    
    def calculate_quality_trend(self, df: pd.DataFrame, 
                               historical_data: Optional[List[pd.DataFrame]] = None) -> Dict[str, Any]:
        """
        Calcula an√°lise de tend√™ncia de qualidade.
        
        Args:
            df: DataFrame com dados da sprint atual
            historical_data: Lista de DataFrames de sprints anteriores
            
        Returns:
            Dicion√°rio com an√°lise completa de tend√™ncia
        """
        try:
            info(\"Calculando tend√™ncia de qualidade...\")\n            \n            if df.empty:\n                return self._get_default_result()\n            \n            # 1. An√°lise de tend√™ncia de bugs\n            bug_trend = self._analyze_bug_trend(df, historical_data)\n            \n            # 2. An√°lise de tend√™ncia de resolu√ß√£o\n            resolution_trend = self._analyze_resolution_trend(df, historical_data)\n            \n            # 3. An√°lise de tend√™ncia de complexidade\n            complexity_trend = self._analyze_complexity_trend(df, historical_data)\n            \n            # 4. An√°lise de d√≠vida t√©cnica\n            technical_debt = self._analyze_technical_debt(df)\n            \n            # 5. An√°lise de taxa de regress√£o\n            regression_rate = self._analyze_regression_rate(df, historical_data)\n            \n            # Calcular score geral de tend√™ncia\n            trend_score = (\n                bug_trend['score'] * self.quality_weights['bug_trend'] +\n                resolution_trend['score'] * self.quality_weights['resolution_trend'] +\n                complexity_trend['score'] * self.quality_weights['complexity_trend'] +\n                technical_debt['score'] * self.quality_weights['technical_debt'] +\n                regression_rate['score'] * self.quality_weights['regression_rate']\n            )\n            \n            # Classificar tend√™ncia\n            trend_direction = self._classify_trend(trend_score)\n            \n            # Previs√£o para pr√≥ximas sprints\n            quality_forecast = self._generate_quality_forecast(\n                bug_trend, resolution_trend, complexity_trend\n            )\n            \n            # Alertas de qualidade\n            quality_alerts = self._generate_quality_alerts(\n                bug_trend, resolution_trend, technical_debt\n            )\n            \n            # Recomenda√ß√µes preventivas\n            preventive_actions = self._generate_preventive_actions(\n                bug_trend, technical_debt, complexity_trend\n            )\n            \n            result = {\n                'trend_score': round(trend_score, 1),\n                'trend_direction': trend_direction,\n                'components': {\n                    'bug_trend': bug_trend,\n                    'resolution_trend': resolution_trend,\n                    'complexity_trend': complexity_trend,\n                    'technical_debt': technical_debt,\n                    'regression_rate': regression_rate\n                },\n                'quality_forecast': quality_forecast,\n                'quality_alerts': quality_alerts,\n                'preventive_actions': preventive_actions,\n                'health_indicators': self._calculate_health_indicators(\n                    bug_trend, resolution_trend, technical_debt\n                ),\n                'risk_assessment': self._assess_quality_risk(\n                    trend_score, quality_alerts\n                )\n            }\n            \n            info(f\"Tend√™ncia de qualidade: {trend_score:.1f} ({trend_direction})\")\n            return result\n            \n        except Exception as e:\n            error(f\"Erro ao calcular tend√™ncia de qualidade: {e}\")\n            return self._get_default_result()\n    \n    def _analyze_bug_trend(self, df: pd.DataFrame, \n                          historical_data: Optional[List[pd.DataFrame]]) -> Dict[str, Any]:\n        \"\"\"Analisa tend√™ncia na taxa de bugs.\"\"\"\n        try:\n            # Identificar bugs na sprint atual\n            current_bugs = self._identify_bugs(df)\n            current_total = len(df)\n            current_bug_rate = current_bugs / current_total if current_total > 0 else 0\n            \n            trend_data = {'current': current_bug_rate}\n            \n            # Analisar hist√≥rico se dispon√≠vel\n            if historical_data:\n                historical_rates = []\n                for hist_df in historical_data[-5:]:  # √öltimas 5 sprints\n                    if not hist_df.empty:\n                        hist_bugs = self._identify_bugs(hist_df)\n                        hist_total = len(hist_df)\n                        hist_rate = hist_bugs / hist_total if hist_total > 0 else 0\n                        historical_rates.append(hist_rate)\n                \n                if historical_rates:\n                    trend_data['historical'] = historical_rates\n                    trend_data['average_historical'] = np.mean(historical_rates)\n                    \n                    # Calcular tend√™ncia (regress√£o linear simples)\n                    if len(historical_rates) >= 3:\n                        x = np.arange(len(historical_rates))\n                        slope, _ = np.polyfit(x, historical_rates, 1)\n                        trend_data['slope'] = slope\n            \n            # Calcular score baseado na tend√™ncia\n            score = self._calculate_bug_trend_score(trend_data)\n            \n            return {\n                'score': score,\n                'current_bug_rate': round(current_bug_rate, 3),\n                'bugs_count': current_bugs,\n                'total_items': current_total,\n                'trend_data': trend_data,\n                'interpretation': self._interpret_bug_trend(trend_data, score)\n            }\n            \n        except Exception:\n            return {\n                'score': 70.0,\n                'current_bug_rate': 0.0,\n                'bugs_count': 0,\n                'total_items': 0,\n                'trend_data': {},\n                'interpretation': 'Dados insuficientes'\n            }\n    \n    def _analyze_resolution_trend(self, df: pd.DataFrame,\n                                 historical_data: Optional[List[pd.DataFrame]]) -> Dict[str, Any]:\n        \"\"\"Analisa tend√™ncia no tempo de resolu√ß√£o.\"\"\"\n        try:\n            # Tempo de resolu√ß√£o atual\n            if 'Dias para Resolu√ß√£o' not in df.columns:\n                return self._get_default_resolution_trend()\n            \n            completed_df = df[\n                (df['Status Categoria'] == 'Done') &\n                (df['Dias para Resolu√ß√£o'].notna()) &\n                (df['Dias para Resolu√ß√£o'] > 0)\n            ]\n            \n            if len(completed_df) == 0:\n                return self._get_default_resolution_trend()\n            \n            current_avg_time = completed_df['Dias para Resolu√ß√£o'].mean()\n            current_median_time = completed_df['Dias para Resolu√ß√£o'].median()\n            \n            trend_data = {\n                'current_avg': current_avg_time,\n                'current_median': current_median_time\n            }\n            \n            # Analisar hist√≥rico\n            if historical_data:\n                historical_times = []\n                for hist_df in historical_data[-5:]:\n                    if not hist_df.empty and 'Dias para Resolu√ß√£o' in hist_df.columns:\n                        hist_completed = hist_df[\n                            (hist_df['Status Categoria'] == 'Done') &\n                            (hist_df['Dias para Resolu√ß√£o'].notna()) &\n                            (hist_df['Dias para Resolu√ß√£o'] > 0)\n                        ]\n                        if len(hist_completed) > 0:\n                            historical_times.append(hist_completed['Dias para Resolu√ß√£o'].mean())\n                \n                if historical_times:\n                    trend_data['historical'] = historical_times\n                    trend_data['average_historical'] = np.mean(historical_times)\n                    \n                    # Calcular tend√™ncia\n                    if len(historical_times) >= 3:\n                        x = np.arange(len(historical_times))\n                        slope, _ = np.polyfit(x, historical_times, 1)\n                        trend_data['slope'] = slope\n            \n            # Calcular score\n            score = self._calculate_resolution_trend_score(trend_data)\n            \n            return {\n                'score': score,\n                'current_avg_time': round(current_avg_time, 1),\n                'current_median_time': round(current_median_time, 1),\n                'completed_items': len(completed_df),\n                'trend_data': trend_data,\n                'interpretation': self._interpret_resolution_trend(trend_data, score)\n            }\n            \n        except Exception:\n            return self._get_default_resolution_trend()\n    \n    def _analyze_complexity_trend(self, df: pd.DataFrame,\n                                 historical_data: Optional[List[pd.DataFrame]]) -> Dict[str, Any]:\n        \"\"\"Analisa tend√™ncia na complexidade das tarefas.\"\"\"\n        try:\n            # Analisar complexidade atrav√©s de story points e tipos\n            complexity_indicators = {\n                'avg_story_points': 0,\n                'large_tasks_ratio': 0,\n                'task_diversity': 0\n            }\n            \n            # Story points m√©dio\n            if 'Story Points' in df.columns:\n                sp_data = df[df['Story Points'].notna() & (df['Story Points'] > 0)]\n                if len(sp_data) > 0:\n                    complexity_indicators['avg_story_points'] = sp_data['Story Points'].mean()\n                    \n                    # Taxa de tarefas grandes (>8 story points)\n                    large_tasks = len(sp_data[sp_data['Story Points'] > 8])\n                    complexity_indicators['large_tasks_ratio'] = large_tasks / len(sp_data)\n            \n            # Diversidade de tipos de tarefa\n            if 'Tipo' in df.columns:\n                unique_types = df['Tipo'].nunique()\n                total_items = len(df)\n                complexity_indicators['task_diversity'] = unique_types / total_items if total_items > 0 else 0\n            \n            # Comparar com hist√≥rico\n            trend_data = {'current': complexity_indicators}\n            \n            if historical_data:\n                historical_complexity = []\n                for hist_df in historical_data[-5:]:\n                    if not hist_df.empty:\n                        hist_indicators = self._extract_complexity_indicators(hist_df)\n                        historical_complexity.append(hist_indicators)\n                \n                if historical_complexity:\n                    trend_data['historical'] = historical_complexity\n            \n            # Calcular score\n            score = self._calculate_complexity_trend_score(trend_data)\n            \n            return {\n                'score': score,\n                'complexity_indicators': complexity_indicators,\n                'trend_data': trend_data,\n                'interpretation': self._interpret_complexity_trend(trend_data, score)\n            }\n            \n        except Exception:\n            return {\n                'score': 70.0,\n                'complexity_indicators': {},\n                'trend_data': {},\n                'interpretation': 'Dados insuficientes'\n            }\n    \n    def _analyze_technical_debt(self, df: pd.DataFrame) -> Dict[str, Any]:\n        \"\"\"Analisa indicadores de d√≠vida t√©cnica.\"\"\"\n        try:\n            debt_indicators = {\n                'technical_tasks_ratio': 0,\n                'maintenance_ratio': 0,\n                'refactoring_ratio': 0,\n                'urgent_fixes_ratio': 0\n            }\n            \n            total_items = len(df)\n            \n            if total_items == 0:\n                return self._get_default_technical_debt()\n            \n            # Identificar tarefas t√©cnicas\n            if 'Tipo' in df.columns or 'T√≠tulo' in df.columns:\n                technical_keywords = [\n                    'refactor', 'refatora√ß√£o', 't√©cnica', 'infraestrutura',\n                    'manuten√ß√£o', 'performance', 'otimiza√ß√£o', 'limpeza'\n                ]\n                \n                maintenance_keywords = [\n                    'manuten√ß√£o', 'atualiza√ß√£o', 'upgrade', 'corre√ß√£o',\n                    'ajuste', 'melhoria'\n                ]\n                \n                urgent_keywords = [\n                    'urgente', 'cr√≠tico', 'hotfix', 'emerg√™ncia'\n                ]\n                \n                # Combinar texto de tipo e t√≠tulo para an√°lise\n                text_columns = []\n                if 'Tipo' in df.columns:\n                    text_columns.append(df['Tipo'].fillna(''))\n                if 'T√≠tulo' in df.columns:\n                    text_columns.append(df['T√≠tulo'].fillna(''))\n                \n                if text_columns:\n                    combined_text = ' '.join([col.str.lower() for col in text_columns])\n                    \n                    # Contar ocorr√™ncias\n                    technical_count = sum(\n                        combined_text.str.contains(keyword, na=False).sum()\n                        for keyword in technical_keywords\n                    )\n                    \n                    maintenance_count = sum(\n                        combined_text.str.contains(keyword, na=False).sum()\n                        for keyword in maintenance_keywords\n                    )\n                    \n                    urgent_count = sum(\n                        combined_text.str.contains(keyword, na=False).sum()\n                        for keyword in urgent_keywords\n                    )\n                    \n                    debt_indicators['technical_tasks_ratio'] = min(1.0, technical_count / total_items)\n                    debt_indicators['maintenance_ratio'] = min(1.0, maintenance_count / total_items)\n                    debt_indicators['urgent_fixes_ratio'] = min(1.0, urgent_count / total_items)\n            \n            # Calcular score de d√≠vida t√©cnica (inverso - menos d√≠vida = melhor score)\n            score = self._calculate_technical_debt_score(debt_indicators)\n            \n            return {\n                'score': score,\n                'debt_indicators': debt_indicators,\n                'interpretation': self._interpret_technical_debt(debt_indicators, score),\n                'debt_level': self._classify_debt_level(score)\n            }\n            \n        except Exception:\n            return self._get_default_technical_debt()\n    \n    def _analyze_regression_rate(self, df: pd.DataFrame,\n                                historical_data: Optional[List[pd.DataFrame]]) -> Dict[str, Any]:\n        \"\"\"Analisa taxa de regress√£o e reincid√™ncia.\"\"\"\n        try:\n            # Identificar poss√≠veis regress√µes\n            regression_indicators = 0\n            total_items = len(df)\n            \n            if total_items == 0:\n                return {'score': 80.0, 'regression_rate': 0, 'interpretation': 'Sem itens'}\n            \n            # Buscar por padr√µes de regress√£o\n            if 'T√≠tulo' in df.columns:\n                regression_keywords = [\n                    'regress√£o', 'voltou', 'novamente', 'denovo', 'again',\n                    'reincid√™ncia', 'reapareceu'\n                ]\n                \n                titles_lower = df['T√≠tulo'].str.lower().fillna('')\n                regression_indicators = sum(\n                    titles_lower.str.contains(keyword, na=False).sum()\n                    for keyword in regression_keywords\n                )\n            \n            # Identificar bugs relacionados a funcionalidades j√° implementadas\n            if 'Tipo' in df.columns:\n                bug_types = ['bug', 'defeito', 'erro']\n                df_lower = df['Tipo'].str.lower().fillna('')\n                bugs_count = sum(\n                    df_lower.str.contains(bug_type, na=False).sum()\n                    for bug_type in bug_types\n                )\n                \n                # Assumir que parte dos bugs s√£o regress√µes\n                regression_indicators += bugs_count * 0.3  # 30% dos bugs podem ser regress√µes\n            \n            regression_rate = min(1.0, regression_indicators / total_items)\n            \n            # Calcular score (inverso - menos regress√£o = melhor)\n            if regression_rate <= 0.05:  # ‚â§5%\n                score = 95\n            elif regression_rate <= 0.1:  # ‚â§10%\n                score = 85\n            elif regression_rate <= 0.15:  # ‚â§15%\n                score = 70\n            elif regression_rate <= 0.25:  # ‚â§25%\n                score = 50\n            else:\n                score = 30\n            \n            return {\n                'score': score,\n                'regression_rate': round(regression_rate, 3),\n                'regression_indicators': int(regression_indicators),\n                'total_items': total_items,\n                'interpretation': self._interpret_regression_rate(regression_rate, score)\n            }\n            \n        except Exception:\n            return {\n                'score': 80.0,\n                'regression_rate': 0,\n                'regression_indicators': 0,\n                'total_items': 0,\n                'interpretation': 'Dados insuficientes'\n            }\n    \n    def _identify_bugs(self, df: pd.DataFrame) -> int:\n        \"\"\"Identifica n√∫mero de bugs no DataFrame.\"\"\"\n        bugs_count = 0\n        \n        if 'Tipo' in df.columns:\n            bug_keywords = ['bug', 'defeito', 'erro', 'falha']\n            df_lower = df['Tipo'].str.lower().fillna('')\n            bugs_count = sum(\n                df_lower.str.contains(keyword, na=False).sum()\n                for keyword in bug_keywords\n            )\n        \n        return bugs_count\n    \n    def _extract_complexity_indicators(self, df: pd.DataFrame) -> Dict[str, float]:\n        \"\"\"Extrai indicadores de complexidade de um DataFrame.\"\"\"\n        indicators = {\n            'avg_story_points': 0,\n            'large_tasks_ratio': 0,\n            'task_diversity': 0\n        }\n        \n        if 'Story Points' in df.columns:\n            sp_data = df[df['Story Points'].notna() & (df['Story Points'] > 0)]\n            if len(sp_data) > 0:\n                indicators['avg_story_points'] = sp_data['Story Points'].mean()\n                large_tasks = len(sp_data[sp_data['Story Points'] > 8])\n                indicators['large_tasks_ratio'] = large_tasks / len(sp_data)\n        \n        if 'Tipo' in df.columns:\n            unique_types = df['Tipo'].nunique()\n            total_items = len(df)\n            indicators['task_diversity'] = unique_types / total_items if total_items > 0 else 0\n        \n        return indicators\n    \n    def _calculate_bug_trend_score(self, trend_data: Dict) -> float:\n        \"\"\"Calcula score baseado na tend√™ncia de bugs.\"\"\"\n        current_rate = trend_data.get('current', 0)\n        \n        # Score base baseado na taxa atual\n        if current_rate <= 0.05:  # ‚â§5%\n            base_score = 90\n        elif current_rate <= 0.1:  # ‚â§10%\n            base_score = 75\n        elif current_rate <= 0.2:  # ‚â§20%\n            base_score = 60\n        else:\n            base_score = 40\n        \n        # Ajustar baseado na tend√™ncia\n        if 'slope' in trend_data:\n            slope = trend_data['slope']\n            if slope < -0.02:  # Tend√™ncia de melhoria\n                base_score += 10\n            elif slope > 0.02:  # Tend√™ncia de piora\n                base_score -= 15\n        \n        return max(10, min(100, base_score))\n    \n    def _calculate_resolution_trend_score(self, trend_data: Dict) -> float:\n        \"\"\"Calcula score baseado na tend√™ncia de resolu√ß√£o.\"\"\"\n        current_avg = trend_data.get('current_avg', 5)\n        \n        # Score base baseado no tempo atual\n        if current_avg <= 3:  # ‚â§3 dias\n            base_score = 90\n        elif current_avg <= 5:  # ‚â§5 dias\n            base_score = 80\n        elif current_avg <= 8:  # ‚â§8 dias\n            base_score = 65\n        elif current_avg <= 12:  # ‚â§12 dias\n            base_score = 50\n        else:\n            base_score = 30\n        \n        # Ajustar baseado na tend√™ncia\n        if 'slope' in trend_data:\n            slope = trend_data['slope']\n            if slope < -0.5:  # Tempos diminuindo\n                base_score += 10\n            elif slope > 1.0:  # Tempos aumentando\n                base_score -= 15\n        \n        return max(10, min(100, base_score))\n    \n    def _calculate_complexity_trend_score(self, trend_data: Dict) -> float:\n        \"\"\"Calcula score baseado na tend√™ncia de complexidade.\"\"\"\n        current = trend_data.get('current', {})\n        \n        base_score = 75  # Score neutro\n        \n        # Ajustar baseado nos indicadores atuais\n        avg_sp = current.get('avg_story_points', 5)\n        large_ratio = current.get('large_tasks_ratio', 0)\n        diversity = current.get('task_diversity', 0.3)\n        \n        # Penalizar alta complexidade\n        if avg_sp > 8:\n            base_score -= 15\n        elif avg_sp > 5:\n            base_score -= 5\n        \n        if large_ratio > 0.3:  # >30% tarefas grandes\n            base_score -= 10\n        elif large_ratio > 0.2:  # >20% tarefas grandes\n            base_score -= 5\n        \n        # Premiar diversidade moderada\n        if 0.2 <= diversity <= 0.5:\n            base_score += 5\n        elif diversity > 0.7:  # Muito diverso pode ser complexo\n            base_score -= 5\n        \n        return max(20, min(100, base_score))\n    \n    def _calculate_technical_debt_score(self, debt_indicators: Dict) -> float:\n        \"\"\"Calcula score de d√≠vida t√©cnica (inverso).\"\"\"\n        technical_ratio = debt_indicators.get('technical_tasks_ratio', 0)\n        maintenance_ratio = debt_indicators.get('maintenance_ratio', 0)\n        urgent_ratio = debt_indicators.get('urgent_fixes_ratio', 0)\n        \n        # Score base alto (pouca d√≠vida)\n        base_score = 85\n        \n        # Penalizar alta propor√ß√£o de tarefas t√©cnicas\n        if technical_ratio > 0.4:  # >40%\n            base_score -= 25\n        elif technical_ratio > 0.3:  # >30%\n            base_score -= 15\n        elif technical_ratio > 0.2:  # >20%\n            base_score -= 10\n        \n        # Penalizar muita manuten√ß√£o\n        if maintenance_ratio > 0.3:\n            base_score -= 15\n        elif maintenance_ratio > 0.2:\n            base_score -= 10\n        \n        # Penalizar fixes urgentes\n        if urgent_ratio > 0.1:  # >10%\n            base_score -= 20\n        elif urgent_ratio > 0.05:  # >5%\n            base_score -= 10\n        \n        return max(20, min(100, base_score))\n    \n    def _classify_trend(self, score: float) -> str:\n        \"\"\"Classifica a tend√™ncia geral de qualidade.\"\"\"\n        if score >= 85:\n            return \"Excelente ‚¨ÜÔ∏è\"\n        elif score >= 75:\n            return \"Melhorando ‚ÜóÔ∏è\"\n        elif score >= 65:\n            return \"Est√°vel ‚û°Ô∏è\"\n        elif score >= 50:\n            return \"Preocupante ‚ÜòÔ∏è\"\n        else:\n            return \"Deteriorando ‚¨áÔ∏è\"\n    \n    def _generate_quality_forecast(self, bug_trend: Dict, resolution_trend: Dict,\n                                  complexity_trend: Dict) -> Dict[str, Any]:\n        \"\"\"Gera previs√£o de qualidade para pr√≥ximas sprints.\"\"\"\n        forecasts = []\n        \n        # Previs√£o baseada em bugs\n        bug_score = bug_trend['score']\n        if bug_score >= 80:\n            forecasts.append(\"üìà Tend√™ncia de baixa incid√™ncia de bugs\")\n        elif bug_score < 50:\n            forecasts.append(\"‚ö†Ô∏è Risco de aumento na taxa de bugs\")\n        \n        # Previs√£o baseada em resolu√ß√£o\n        resolution_score = resolution_trend['score']\n        if resolution_score >= 80:\n            forecasts.append(\"‚è±Ô∏è Tempos de resolu√ß√£o devem permanecer saud√°veis\")\n        elif resolution_score < 50:\n            forecasts.append(\"üêå Risco de aumento nos tempos de resolu√ß√£o\")\n        \n        # Previs√£o baseada em complexidade\n        complexity_score = complexity_trend['score']\n        if complexity_score < 60:\n            forecasts.append(\"üîß Complexidade crescente pode impactar qualidade\")\n        \n        return {\n            'short_term': forecasts[:2],  # Pr√≥ximas 1-2 sprints\n            'medium_term': forecasts[2:],  # Pr√≥ximas 3-5 sprints\n            'confidence_level': self._calculate_forecast_confidence(\n                bug_trend, resolution_trend, complexity_trend\n            )\n        }\n    \n    def _generate_quality_alerts(self, bug_trend: Dict, resolution_trend: Dict,\n                                technical_debt: Dict) -> List[Dict[str, Any]]:\n        \"\"\"Gera alertas de qualidade.\"\"\"\n        alerts = []\n        \n        # Alertas de bugs\n        if bug_trend['score'] < 50:\n            alerts.append({\n                'type': 'bug_increase',\n                'severity': 'high',\n                'message': f\"Taxa de bugs em {bug_trend['current_bug_rate']:.1%} - acima do aceit√°vel\",\n                'action': 'Revisar processo de testes e qualidade'\n            })\n        \n        # Alertas de tempo de resolu√ß√£o\n        if resolution_trend['score'] < 50:\n            alerts.append({\n                'type': 'resolution_time',\n                'severity': 'medium',\n                'message': f\"Tempo m√©dio de resolu√ß√£o: {resolution_trend.get('current_avg_time', 0):.1f} dias\",\n                'action': 'Investigar gargalos no processo'\n            })\n        \n        # Alertas de d√≠vida t√©cnica\n        if technical_debt['score'] < 60:\n            alerts.append({\n                'type': 'technical_debt',\n                'severity': 'medium',\n                'message': \"Alta propor√ß√£o de tarefas t√©cnicas detectada\",\n                'action': 'Planejar redu√ß√£o da d√≠vida t√©cnica'\n            })\n        \n        return alerts\n    \n    def _generate_preventive_actions(self, bug_trend: Dict, technical_debt: Dict,\n                                   complexity_trend: Dict) -> List[str]:\n        \"\"\"Gera a√ß√µes preventivas para manter qualidade.\"\"\"\n        actions = []\n        \n        if bug_trend['score'] < 70:\n            actions.extend([\n                \"üîç Implementar code review obrigat√≥rio\",\n                \"üß™ Aumentar cobertura de testes automatizados\"\n            ])\n        \n        if technical_debt['score'] < 70:\n            actions.extend([\n                \"üèóÔ∏è Alocar tempo para refatora√ß√£o em cada sprint\",\n                \"üìä Monitorar m√©tricas de qualidade de c√≥digo\"\n            ])\n        \n        if complexity_trend['score'] < 65:\n            actions.extend([\n                \"‚úÇÔ∏è Quebrar hist√≥rias grandes em menores\",\n                \"üìã Melhorar crit√©rios de aceita√ß√£o\"\n            ])\n        \n        # A√ß√µes gerais\n        actions.extend([\n            \"üìö Documentar padr√µes de qualidade da equipe\",\n            \"üéØ Definir m√©tricas de qualidade claras\"\n        ])\n        \n        return actions[:5]  # Limitar a 5 a√ß√µes\n    \n    def _calculate_health_indicators(self, bug_trend: Dict, resolution_trend: Dict,\n                                   technical_debt: Dict) -> Dict[str, str]:\n        \"\"\"Calcula indicadores de sa√∫de da qualidade.\"\"\"\n        indicators = {}\n        \n        # Sa√∫de de bugs\n        bug_score = bug_trend['score']\n        if bug_score >= 80:\n            indicators['bug_health'] = \"Saud√°vel\"\n        elif bug_score >= 60:\n            indicators['bug_health'] = \"Moderada\"\n        else:\n            indicators['bug_health'] = \"Cr√≠tica\"\n        \n        # Sa√∫de de resolu√ß√£o\n        resolution_score = resolution_trend['score']\n        if resolution_score >= 80:\n            indicators['resolution_health'] = \"Saud√°vel\"\n        elif resolution_score >= 60:\n            indicators['resolution_health'] = \"Moderada\"\n        else:\n            indicators['resolution_health'] = \"Cr√≠tica\"\n        \n        # Sa√∫de de d√≠vida t√©cnica\n        debt_score = technical_debt['score']\n        if debt_score >= 80:\n            indicators['debt_health'] = \"Saud√°vel\"\n        elif debt_score >= 60:\n            indicators['debt_health'] = \"Moderada\"\n        else:\n            indicators['debt_health'] = \"Cr√≠tica\"\n        \n        return indicators\n    \n    def _assess_quality_risk(self, trend_score: float, alerts: List[Dict]) -> str:\n        \"\"\"Avalia risco geral de qualidade.\"\"\"\n        high_severity_alerts = len([a for a in alerts if a.get('severity') == 'high'])\n        medium_severity_alerts = len([a for a in alerts if a.get('severity') == 'medium'])\n        \n        if trend_score < 50 or high_severity_alerts >= 2:\n            return \"Alto\"\n        elif trend_score < 65 or high_severity_alerts >= 1 or medium_severity_alerts >= 2:\n            return \"M√©dio\"\n        else:\n            return \"Baixo\"\n    \n    def _calculate_forecast_confidence(self, bug_trend: Dict, resolution_trend: Dict,\n                                     complexity_trend: Dict) -> str:\n        \"\"\"Calcula confian√ßa da previs√£o.\"\"\"\n        # Verificar se temos dados hist√≥ricos suficientes\n        has_bug_history = 'historical' in bug_trend.get('trend_data', {})\n        has_resolution_history = 'historical' in resolution_trend.get('trend_data', {})\n        \n        if has_bug_history and has_resolution_history:\n            return \"Alta\"\n        elif has_bug_history or has_resolution_history:\n            return \"M√©dia\"\n        else:\n            return \"Baixa\"\n    \n    # M√©todos auxiliares para resultados padr√£o\n    def _get_default_result(self) -> Dict[str, Any]:\n        \"\"\"Retorna resultado padr√£o.\"\"\"\n        return {\n            'trend_score': 70.0,\n            'trend_direction': \"Est√°vel ‚û°Ô∏è\",\n            'components': {\n                'bug_trend': {'score': 70, 'interpretation': 'Dados insuficientes'},\n                'resolution_trend': {'score': 70, 'interpretation': 'Dados insuficientes'},\n                'complexity_trend': {'score': 70, 'interpretation': 'Dados insuficientes'},\n                'technical_debt': {'score': 70, 'interpretation': 'Dados insuficientes'},\n                'regression_rate': {'score': 70, 'interpretation': 'Dados insuficientes'}\n            },\n            'quality_forecast': {'short_term': [], 'medium_term': [], 'confidence_level': 'Baixa'},\n            'quality_alerts': [],\n            'preventive_actions': [\"Coletar mais dados para an√°lise precisa\"],\n            'health_indicators': {'bug_health': 'Indeterminada', 'resolution_health': 'Indeterminada', 'debt_health': 'Indeterminada'},\n            'risk_assessment': 'Indeterminado'\n        }\n    \n    def _get_default_resolution_trend(self) -> Dict[str, Any]:\n        \"\"\"Retorna resultado padr√£o para tend√™ncia de resolu√ß√£o.\"\"\"\n        return {\n            'score': 70.0,\n            'current_avg_time': 0,\n            'current_median_time': 0,\n            'completed_items': 0,\n            'trend_data': {},\n            'interpretation': 'Dados insuficientes'\n        }\n    \n    def _get_default_technical_debt(self) -> Dict[str, Any]:\n        \"\"\"Retorna resultado padr√£o para d√≠vida t√©cnica.\"\"\"\n        return {\n            'score': 70.0,\n            'debt_indicators': {},\n            'interpretation': 'Dados insuficientes',\n            'debt_level': 'Indeterminado'\n        }\n    \n    # M√©todos de interpreta√ß√£o\n    def _interpret_bug_trend(self, trend_data: Dict, score: float) -> str:\n        \"\"\"Interpreta tend√™ncia de bugs.\"\"\"\n        current_rate = trend_data.get('current', 0)\n        \n        if score >= 80:\n            return f\"Baixa taxa de bugs ({current_rate:.1%}) - qualidade excelente\"\n        elif score >= 60:\n            return f\"Taxa de bugs moderada ({current_rate:.1%}) - monitorar\"\n        else:\n            return f\"Taxa de bugs alta ({current_rate:.1%}) - requer a√ß√£o imediata\"\n    \n    def _interpret_resolution_trend(self, trend_data: Dict, score: float) -> str:\n        \"\"\"Interpreta tend√™ncia de resolu√ß√£o.\"\"\"\n        current_avg = trend_data.get('current_avg', 0)\n        \n        if score >= 80:\n            return f\"Tempos de resolu√ß√£o saud√°veis ({current_avg:.1f} dias)\"\n        elif score >= 60:\n            return f\"Tempos de resolu√ß√£o moderados ({current_avg:.1f} dias)\"\n        else:\n            return f\"Tempos de resolu√ß√£o elevados ({current_avg:.1f} dias)\"\n    \n    def _interpret_complexity_trend(self, trend_data: Dict, score: float) -> str:\n        \"\"\"Interpreta tend√™ncia de complexidade.\"\"\"\n        if score >= 75:\n            return \"Complexidade das tarefas sob controle\"\n        elif score >= 60:\n            return \"Complexidade moderada - monitorar\"\n        else:\n            return \"Complexidade elevada - simplificar tarefas\"\n    \n    def _interpret_technical_debt(self, debt_indicators: Dict, score: float) -> str:\n        \"\"\"Interpreta n√≠vel de d√≠vida t√©cnica.\"\"\"\n        technical_ratio = debt_indicators.get('technical_tasks_ratio', 0)\n        \n        if score >= 80:\n            return \"Baixa d√≠vida t√©cnica - boa sa√∫de do c√≥digo\"\n        elif score >= 60:\n            return f\"D√≠vida t√©cnica moderada ({technical_ratio:.1%} tarefas t√©cnicas)\"\n        else:\n            return f\"Alta d√≠vida t√©cnica ({technical_ratio:.1%} tarefas t√©cnicas) - planejar redu√ß√£o\"\n    \n    def _interpret_regression_rate(self, regression_rate: float, score: float) -> str:\n        \"\"\"Interpreta taxa de regress√£o.\"\"\"\n        if score >= 80:\n            return f\"Baixa taxa de regress√£o ({regression_rate:.1%}) - boa estabilidade\"\n        elif score >= 60:\n            return f\"Taxa de regress√£o moderada ({regression_rate:.1%}) - monitorar\"\n        else:\n            return f\"Alta taxa de regress√£o ({regression_rate:.1%}) - revisar testes\"\n    \n    def _classify_debt_level(self, score: float) -> str:\n        \"\"\"Classifica n√≠vel de d√≠vida t√©cnica.\"\"\"\n        if score >= 80:\n            return \"Baixa\"\n        elif score >= 60:\n            return \"Moderada\"\n        elif score >= 40:\n            return \"Alta\"\n        else:\n            return \"Cr√≠tica\"\n    \n    def create_trend_overview_chart(self, quality_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gr√°fico de overview da tend√™ncia de qualidade.\"\"\"\n        try:\n            components = quality_data['components']\n            \n            categories = ['Bugs', 'Resolu√ß√£o', 'Complexidade', 'D√≠vida T√©cnica', 'Regress√£o']\n            scores = [\n                components['bug_trend']['score'],\n                components['resolution_trend']['score'],\n                components['complexity_trend']['score'],\n                components['technical_debt']['score'],\n                components['regression_rate']['score']\n            ]\n            \n            # Cores baseadas nos scores\n            colors = []\n            for score in scores:\n                if score >= 80:\n                    colors.append('#28a745')  # Verde\n                elif score >= 60:\n                    colors.append('#ffc107')  # Amarelo\n                else:\n                    colors.append('#dc3545')  # Vermelho\n            \n            fig = go.Figure()\n            \n            fig.add_trace(go.Bar(\n                x=categories,\n                y=scores,\n                marker_color=colors,\n                text=[f'{s:.0f}' for s in scores],\n                textposition='outside',\n                hovertemplate='<b>%{x}</b><br>Score: %{y:.1f}<extra></extra>'\n            ))\n            \n            # Linha de meta (80)\n            fig.add_hline(y=80, line_dash=\"dash\", line_color=\"green\",\n                         annotation_text=\"Meta de Qualidade (80)\")\n            \n            fig.update_layout(\n                title=f\"Tend√™ncia de Qualidade - Score Geral: {quality_data['trend_score']:.1f} ({quality_data['trend_direction']})\",\n                xaxis_title=\"Componentes\",\n                yaxis_title=\"Score\",\n                yaxis=dict(range=[0, 100]),\n                showlegend=False\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gr√°fico de tend√™ncia: {e}\")\n            return go.Figure()\n    \n    def create_quality_forecast_chart(self, quality_data: Dict[str, Any]) -> go.Figure:\n        \"\"\"Cria gr√°fico de previs√£o de qualidade.\"\"\"\n        try:\n            # Simular dados hist√≥ricos e proje√ß√£o\n            # Em implementa√ß√£o real, usaria dados hist√≥ricos reais\n            sprints = ['Sprint -4', 'Sprint -3', 'Sprint -2', 'Sprint -1', 'Sprint Atual', 'Proje√ß√£o +1', 'Proje√ß√£o +2']\n            \n            # Simular tend√™ncias baseadas nos scores atuais\n            current_score = quality_data['trend_score']\n            \n            # Criar tend√™ncia simulada\n            historical_scores = [\n                current_score - 15 + np.random.normal(0, 3),\n                current_score - 10 + np.random.normal(0, 3),\n                current_score - 5 + np.random.normal(0, 3),\n                current_score - 2 + np.random.normal(0, 3),\n                current_score\n            ]\n            \n            # Proje√ß√£o baseada na tend√™ncia\n            if current_score >= 75:\n                projected_scores = [current_score + 2, current_score + 3]\n            elif current_score >= 60:\n                projected_scores = [current_score + 1, current_score + 1]\n            else:\n                projected_scores = [current_score - 1, current_score - 2]\n            \n            all_scores = historical_scores + projected_scores\n            \n            fig = go.Figure()\n            \n            # Linha hist√≥rica\n            fig.add_trace(go.Scatter(\n                x=sprints[:5],\n                y=all_scores[:5],\n                mode='lines+markers',\n                name='Hist√≥rico',\n                line=dict(color='blue', width=3),\n                marker=dict(size=8)\n            ))\n            \n            # Linha de proje√ß√£o\n            fig.add_trace(go.Scatter(\n                x=sprints[4:],\n                y=all_scores[4:],\n                mode='lines+markers',\n                name='Proje√ß√£o',\n                line=dict(color='orange', width=3, dash='dash'),\n                marker=dict(size=8)\n            ))\n            \n            # Zona de meta\n            fig.add_hline(y=80, line_dash=\"dash\", line_color=\"green\",\n                         annotation_text=\"Meta de Qualidade\")\n            \n            fig.update_layout(\n                title=\"Proje√ß√£o de Tend√™ncia de Qualidade\",\n                xaxis_title=\"Sprints\",\n                yaxis_title=\"Score de Qualidade\",\n                yaxis=dict(range=[0, 100]),\n                hovermode='x unified'\n            )\n            \n            return fig\n            \n        except Exception as e:\n            error(f\"Erro ao criar gr√°fico de proje√ß√£o: {e}\")\n            return go.Figure()"